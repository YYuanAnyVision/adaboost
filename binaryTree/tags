!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
BINARYTREE_HPP	binarytree.hpp	8;"	d
Train	binarytree.cpp	/^bool binaryTree::Train(  const Mat &neg_data,			\/* input, format-> numbers0 x featuredim *\/$/;"	f	class:binaryTree	signature:( const Mat &neg_data, const Mat &pos_data, const tree_para &paras )
Train	binarytree.hpp	/^		bool Train( $/;"	p	class:binaryTree	access:public	signature:( const Mat &neg_data, const Mat &pos_data, const tree_para &paras )
biTree	binarytree.hpp	/^struct biTree$/;"	s
biTree::child	binarytree.hpp	/^	Mat child;		\/* Kx1 child index for each node *\/$/;"	m	struct:biTree	access:public
biTree::depth	binarytree.hpp	/^	Mat depth;		\/* Kx1 depth of node*\/$/;"	m	struct:biTree	access:public
biTree::fids	binarytree.hpp	/^	Mat fids;		\/* Kx1 feature index for each node , K for number of nodes*\/$/;"	m	struct:biTree	access:public
biTree::hs	binarytree.hpp	/^	Mat hs;			\/* Kx1 log ratio (.5*log(p\/(1-p)) at each node, used later to decide polarity *\/$/;"	m	struct:biTree	access:public
biTree::thrs	binarytree.hpp	/^	Mat thrs;		\/* Kx1 thresholds for each node *\/$/;"	m	struct:biTree	access:public
biTree::weights	binarytree.hpp	/^	Mat weights;	\/* Kx1 total sample weight at each node *\/$/;"	m	struct:biTree	access:public
binaryTree	binarytree.hpp	/^class binaryTree$/;"	c
binaryTree::Train	binarytree.cpp	/^bool binaryTree::Train(  const Mat &neg_data,			\/* input, format-> numbers0 x featuredim *\/$/;"	f	class:binaryTree	signature:( const Mat &neg_data, const Mat &pos_data, const tree_para &paras )
binaryTree::Train	binarytree.hpp	/^		bool Train( $/;"	p	class:binaryTree	access:public	signature:( const Mat &neg_data, const Mat &pos_data, const tree_para &paras )
binaryTree::checkTreeParas	binarytree.cpp	/^bool binaryTree::checkTreeParas( const tree_para & p )		\/* input parameter *\/$/;"	f	class:binaryTree	signature:( const tree_para & p )
binaryTree::checkTreeParas	binarytree.hpp	/^		bool checkTreeParas( const tree_para & p );		\/* input parameter *\/$/;"	p	class:binaryTree	access:private	signature:( const tree_para & p )
checkTreeParas	binarytree.cpp	/^bool binaryTree::checkTreeParas( const tree_para & p )		\/* input parameter *\/$/;"	f	class:binaryTree	signature:( const tree_para & p )
checkTreeParas	binarytree.hpp	/^		bool checkTreeParas( const tree_para & p );		\/* input parameter *\/$/;"	p	class:binaryTree	access:private	signature:( const tree_para & p )
child	binarytree.hpp	/^	Mat child;		\/* Kx1 child index for each node *\/$/;"	m	struct:biTree	access:public
depth	binarytree.hpp	/^	Mat depth;		\/* Kx1 depth of node*\/$/;"	m	struct:biTree	access:public
fids	binarytree.hpp	/^	Mat fids;		\/* Kx1 feature index for each node , K for number of nodes*\/$/;"	m	struct:biTree	access:public
fracFtrs	binarytree.hpp	/^	double	fracFtrs;	\/* fraction of features to sample for each node split *\/$/;"	m	struct:tree_para	access:public
hs	binarytree.hpp	/^	Mat hs;			\/* Kx1 log ratio (.5*log(p\/(1-p)) at each node, used later to decide polarity *\/$/;"	m	struct:biTree	access:public
maxDepth	binarytree.hpp	/^	int		maxDepth;   \/* max depth of the tree *\/$/;"	m	struct:tree_para	access:public
minWeight	binarytree.hpp	/^	double	minWeight;	\/* minimum sample weight allow split*\/$/;"	m	struct:tree_para	access:public
nBins	binarytree.hpp	/^	int		nBins;		\/* maximum number of quantization bins, better <=256 *\/$/;"	m	struct:tree_para	access:public
nThreads	binarytree.hpp	/^	int		nThreads;	\/* max number of computational threads to use *\/$/;"	m	struct:tree_para	access:public
num_neg_samples	binarytree.cpp	/^	int num_neg_samples;$/;"	l
num_pos_samples	binarytree.cpp	/^	int num_pos_samples;$/;"	l
thrs	binarytree.hpp	/^	Mat thrs;		\/* Kx1 thresholds for each node *\/$/;"	m	struct:biTree	access:public
tree_para	binarytree.hpp	/^	tree_para()$/;"	f	struct:tree_para	access:public	signature:()
tree_para	binarytree.hpp	/^struct tree_para$/;"	s
tree_para::fracFtrs	binarytree.hpp	/^	double	fracFtrs;	\/* fraction of features to sample for each node split *\/$/;"	m	struct:tree_para	access:public
tree_para::maxDepth	binarytree.hpp	/^	int		maxDepth;   \/* max depth of the tree *\/$/;"	m	struct:tree_para	access:public
tree_para::minWeight	binarytree.hpp	/^	double	minWeight;	\/* minimum sample weight allow split*\/$/;"	m	struct:tree_para	access:public
tree_para::nBins	binarytree.hpp	/^	int		nBins;		\/* maximum number of quantization bins, better <=256 *\/$/;"	m	struct:tree_para	access:public
tree_para::nThreads	binarytree.hpp	/^	int		nThreads;	\/* max number of computational threads to use *\/$/;"	m	struct:tree_para	access:public
tree_para::tree_para	binarytree.hpp	/^	tree_para()$/;"	f	struct:tree_para	access:public	signature:()
weights	binarytree.hpp	/^	Mat weights;	\/* Kx1 total sample weight at each node *\/$/;"	m	struct:biTree	access:public
