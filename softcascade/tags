!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
Apply	main.cpp	/^        ab.Apply( neg_train_data, pre_neg_score);$/;"	p	file:	signature:( neg_train_data, pre_neg_score)
Apply	main.cpp	/^        ab.Apply( pos_train_data, pre_pos_score);$/;"	p	file:	signature:( pos_train_data, pre_pos_score)
Apply	softcascade.cpp	/^bool softcascade::Apply( const Mat &input_image,        \/*  in: !!! image !!! *\/$/;"	f	class:softcascade	signature:( const Mat &input_image, vector<Rect> &results, vector<double> &confidence)
Apply	softcascade.cpp	/^bool softcascade::Apply( const vector<Mat> &input_data,      \/*  in: channels feature which has a continuous mem like nchannelsxfeature_widthxfeature_height*\/$/;"	f	class:softcascade	signature:( const vector<Mat> &input_data, vector<Rect> &results, vector<double> &confidence) const
Apply	softcascade.hpp	/^		bool Apply( const vector<Mat> &input_data,		\/*  in: channel features, input_data.size() == nchannels *\/$/;"	p	class:softcascade	access:public	signature:( const vector<Mat> &input_data, vector<Rect> &results, vector<double> &confidence) const
Apply	softcascade.hpp	/^        bool Apply( const Mat &input_image,             \/*  in: !!! image !!! *\/$/;"	p	class:softcascade	access:public	signature:( const Mat &input_image, vector<Rect> &results, vector<double> &confidence)
Combine	main.cpp	/^        sc.Combine( t_v );$/;"	p	file:	signature:( t_v )
Combine	softcascade.cpp	/^bool softcascade::Combine(vector<Adaboost> &ads )$/;"	f	class:softcascade	signature:(vector<Adaboost> &ads )
Combine	softcascade.hpp	/^		bool Combine( vector<Adaboost> &ads );$/;"	p	class:softcascade	access:public	signature:( vector<Adaboost> &ads )
Km	main.cpp	/^    Mat Km = get_Km(1);$/;"	l
Load	softcascade.cpp	/^bool softcascade::Load( string path_to_model )      \/* in : path of the model, shoule be a xml file saved by opencv FileStorage *\/$/;"	f	class:softcascade	signature:( string path_to_model )
Load	softcascade.hpp	/^		bool Load( string path_to_model );		\/* in : path of the model, shoule be a xml file saved by opencv FileStorage *\/$/;"	p	class:softcascade	access:public	signature:( string path_to_model )
Nthreads	main.cpp	/^	int Nthreads = omp_get_max_threads();$/;"	l
P1	main.cpp	22;"	d	file:
Predict	softcascade.hpp	/^		template < typename T> bool Predict(  const T *data,            \/* in : test data, must be continuous in memory *\/$/;"	f	class:softcascade	access:public	signature:( const T *data, double &score) const
Predict	softcascade.hpp	/^        bool Predict( const Mat &testData,              \/* in : featureDim x numberOfSamples *\/$/;"	f	class:softcascade	access:public	signature:( const Mat &testData, Mat &confidence)
SOFTCASCADE	softcascade.hpp	2;"	d
Save	softcascade.cpp	/^bool softcascade::Save( string path_to_model )      \/*  in: where to save the model, models is saved by opencv FileStorage *\/$/;"	f	class:softcascade	signature:( string path_to_model )
Save	softcascade.hpp	/^		bool Save( string path_to_model );		\/*  in: where to save the model, models is saved by opencv FileStorage *\/$/;"	p	class:softcascade	access:public	signature:( string path_to_model )
SetDebug	main.cpp	/^        Adaboost ab;ab.SetDebug(false);  $/;"	p	file:	signature:(false)
TEST_STAT_SLIDE	main.cpp	23;"	d	file:
Train	main.cpp	/^        ab.Train( neg_train_data, pos_train_data, cas_para.nWeaks[stage], tree_par);$/;"	p	file:	signature:( neg_train_data, pos_train_data, cas_para.nWeaks[stage], tree_par)
_apply	softcascade.cpp	/^template <typename T> void _apply( const T *input_data,                 \/* in : (nchannels*nheight)x(nwidth) channels feature, already been scaled with shrink*\/$/;"	f	signature:( const T *input_data, const int &in_width, const int &in_height, const Mat &fids, const Mat &child, const Mat &thrs, const Mat &hs, const cascadeParameter &opts, const int &tree_depth, vector<Rect> &results, vector<double> &confidence )
ab	main.cpp	/^        Adaboost ab;ab.SetDebug(false);  $/;"	l
accu_neg	main.cpp	/^        vector<Mat> accu_neg;$/;"	l
approPyramid	softcascade.cpp	/^    vector< vector<Mat> > approPyramid;$/;"	l
appro_scales	softcascade.cpp	/^    vector<double> appro_scales;$/;"	l
at	softcascade.cpp	/^            m_nodes.at<int>(counter,0) = nodes_info.at<int>(i,0);$/;"	p	file:	signature:(counter,0)
at	softcascade.cpp	/^            v_features[n_c].at<float>( position.y, position.x) += abs(m_hs.at<double>(r,c));$/;"	p	file:	signature:( position.y, position.x)
at	softcascade.hpp	/^                confidence.at<double>(c,0) = score;$/;"	p	signature:(c,0)
avg_neg_score	main.cpp	/^    double avg_neg_score = 0;$/;"	l
avg_pos_score	main.cpp	/^    double avg_pos_score = 0;$/;"	l
avg_train_neg_score	main.cpp	/^        double avg_train_neg_score = 0;$/;"	l
avg_train_pos_score	main.cpp	/^        double avg_train_pos_score = 0;$/;"	l
basename	main.cpp	/^		string basename = bf::basename(s);$/;"	l
basename	main.cpp	/^            string basename = bf::basename( s );$/;"	l
basename	main.cpp	/^        string basename = bf::basename(t_path);$/;"	l
bts	softcascade.cpp	/^        const vector<binaryTree> bts = ads[c].getTrees();$/;"	l
c	main.cpp	/^                    stringstream ss;ss<<c;string index_string;ss>>index_string;$/;"	l
c_path	main.cpp	/^    bf::path c_path(in_path);   $/;"	p	file:	signature:(in_path)
cas_para	main.cpp	/^	cascadeParameter cas_para;$/;"	l
cascCal	softcascade.cpp	/^    const double cascCal  = opts.cascCal;$/;"	l
cascCal	softcascade.hpp	/^	double cascCal;						\/* [.005] cascade calibration (affects speed\/accuracy) *\/$/;"	m	struct:cascadeParameter	access:public
cascThr	softcascade.cpp	/^    const double cascThr  = opts.cascThr;$/;"	l
cascThr	softcascade.hpp	/^	double cascThr;						\/* [-1] constant cascade threshold (affects speed\/accuracy)*\/$/;"	m	struct:cascadeParameter	access:public
cascadeParameter	softcascade.hpp	/^	cascadeParameter()$/;"	f	struct:cascadeParameter	access:public	signature:()
cascadeParameter	softcascade.hpp	/^struct cascadeParameter$/;"	s
cascadeParameter::cascCal	softcascade.hpp	/^	double cascCal;						\/* [.005] cascade calibration (affects speed\/accuracy) *\/$/;"	m	struct:cascadeParameter	access:public
cascadeParameter::cascThr	softcascade.hpp	/^	double cascThr;						\/* [-1] constant cascade threshold (affects speed\/accuracy)*\/$/;"	m	struct:cascadeParameter	access:public
cascadeParameter::cascadeParameter	softcascade.hpp	/^	cascadeParameter()$/;"	f	struct:cascadeParameter	access:public	signature:()
cascadeParameter::filter	softcascade.hpp	/^	vector<int> filter;					\/* de-correlation filter parameters, eg [5 5]  *\/$/;"	m	struct:cascadeParameter	access:public
cascadeParameter::infos	softcascade.hpp	/^	string infos;						\/* other informations~~ *\/$/;"	m	struct:cascadeParameter	access:public
cascadeParameter::modelDs	softcascade.hpp	/^	Size modelDs;						\/* model height+width without padding (eg [100 41]) *\/$/;"	m	struct:cascadeParameter	access:public
cascadeParameter::modelDsPad	softcascade.hpp	/^	Size modelDsPad;					\/* model height+width with padding (eg [128 64])*\/$/;"	m	struct:cascadeParameter	access:public
cascadeParameter::nAccNeg	softcascade.hpp	/^	int nAccNeg;						\/* [10000] max number of neg windows to accumulate*\/$/;"	m	struct:cascadeParameter	access:public
cascadeParameter::nNeg	softcascade.hpp	/^	int nNeg;							\/* [5000] max number of neg windows to sample*\/$/;"	m	struct:cascadeParameter	access:public
cascadeParameter::nPerNeg	softcascade.hpp	/^	int nPerNeg;						\/* [25]  max number of neg windows to sample per image*\/$/;"	m	struct:cascadeParameter	access:public
cascadeParameter::nPos	softcascade.hpp	/^	int nPos;							\/* [-1 -> inf] max number of pos windows to sample *\/						$/;"	m	struct:cascadeParameter	access:public
cascadeParameter::nWeaks	softcascade.hpp	/^	vector<int> nWeaks;					\/* [128] vector defining number weak clfs per stagemodel eg[64 128 256 1024]*\/$/;"	m	struct:cascadeParameter	access:public
cascadeParameter::nchannels	softcascade.hpp	/^    int    nchannels;                   \/* ----------> number of channels, usually 1 *\/$/;"	m	struct:cascadeParameter	access:public
cascadeParameter::negImgDir	softcascade.hpp	/^    string negImgDir;                   \/* negative image directory *\/$/;"	m	struct:cascadeParameter	access:public
cascadeParameter::pBoost_nweaks	softcascade.hpp	/^	int pBoost_nweaks;					\/* parameters for boosting *\/$/;"	m	struct:cascadeParameter	access:public
cascadeParameter::pBoost_pTree	softcascade.hpp	/^	tree_para pBoost_pTree;				\/* parameters for boosting *\/$/;"	m	struct:cascadeParameter	access:public
cascadeParameter::pad	softcascade.hpp	/^    Size pad;                           \/* ----------> get it from feature generator *\/$/;"	m	struct:cascadeParameter	access:public
cascadeParameter::posGtDir	softcascade.hpp	/^    string posGtDir;                    \/* positive groundtruth directory *\/$/;"	m	struct:cascadeParameter	access:public
cascadeParameter::posImgDir	softcascade.hpp	/^    string posImgDir;                   \/* positive image directory *\/$/;"	m	struct:cascadeParameter	access:public
cascadeParameter::shrink	softcascade.hpp	/^	int shrink;							\/* ----------> should be provided by the chnPyramid *\/$/;"	m	struct:cascadeParameter	access:public
cascadeParameter::stride	softcascade.hpp	/^	int stride;							\/* [4] spatial stride between detection windows *\/$/;"	m	struct:cascadeParameter	access:public
checkModel	softcascade.cpp	/^bool softcascade::checkModel() const$/;"	f	class:softcascade	signature:() const
checkModel	softcascade.hpp	/^		bool checkModel() const;$/;"	p	class:softcascade	access:public	signature:() const
chns	softcascade.cpp	/^    vector<Mat> chns;$/;"	l
chnsPyramid	softcascade.cpp	/^    m_feature_gen.chnsPyramid( image, approPyramid, appro_scales, scale_h, scale_w);$/;"	p	file:	signature:( image, approPyramid, appro_scales, scale_h, scale_w)
cids	softcascade.cpp	/^    unsigned int *cids = new unsigned int[total_dim];$/;"	l
clear	main.cpp	/^	image_path_vector.clear();$/;"	p	file:	signature:()
clear	main.cpp	/^    origsamples.clear();$/;"	p	file:	signature:()
clear	main.cpp	/^    samples.clear();$/;"	p	file:	signature:()
cnt	main.cpp	/^    int cnt = std::count_if($/;"	l
computeChannels	main.cpp	/^                ff1.computeChannels( pos_samples[c], feas );$/;"	p	file:	signature:( pos_samples[c], feas )
computeChannels	main.cpp	/^            ff1.computeChannels( accu_neg[c], feas );$/;"	p	file:	signature:( accu_neg[c], feas )
computeChannels	main.cpp	/^        ff1.computeChannels( test_neg_orig[c], feas );$/;"	p	file:	signature:( test_neg_orig[c], feas )
computeChannels	main.cpp	/^        ff1.computeChannels( test_pos_all[c], feas );$/;"	p	file:	signature:( test_pos_all[c], feas )
computeChannels	softcascade.cpp	/^    m_feature_gen.computeChannels( input_image, chns);$/;"	p	file:	signature:( input_image, chns)
compute_lambdas	main.cpp	/^            ff1.compute_lambdas( pos_origsamples );$/;"	p	file:	signature:( pos_origsamples )
conf_string	main.cpp	/^			stringstream ss; ss<<confs[c];string conf_string;ss>>conf_string;$/;"	l
conf_v	main.cpp	/^            vector<double> conf_v;$/;"	l
confs	main.cpp	/^			stringstream ss; ss<<confs[c];string conf_string;ss>>conf_string;$/;"	l
confs	main.cpp	/^        vector<Rect> re;vector<double> confs;$/;"	l
convTri	main.cpp	/^                    ff1.convTri( feas[i], feas[i], Km );$/;"	p	file:	signature:( feas[i], feas[i], Km )
convTri	main.cpp	/^                ff1.convTri( feas[i], feas[i], Km );$/;"	p	file:	signature:( feas[i], feas[i], Km )
convTri	main.cpp	/^            ff1.convTri( feas[i], feas[i], Km );$/;"	p	file:	signature:( feas[i], feas[i], Km )
copyTo	main.cpp	/^		tmp.copyTo(for_test_feat);$/;"	p	file:	signature:(for_test_feat)
copyTo	softcascade.cpp	/^            (*ptr).child.copyTo( m_child.row(counter).colRange(0,nodes_info.at<int>(i,0)) );$/;"	p	file:	signature:( m_child.row(counter).colRange(0,nodes_info.at<int>(i,0)) )
copyTo	softcascade.cpp	/^            (*ptr).depth.copyTo( m_depth.row(counter).colRange(0,nodes_info.at<int>(i,0)) );$/;"	p	file:	signature:( m_depth.row(counter).colRange(0,nodes_info.at<int>(i,0)) )
copyTo	softcascade.cpp	/^            (*ptr).fids.copyTo( m_fids.row(counter).colRange(0,nodes_info.at<int>(i,0)) );$/;"	p	file:	signature:( m_fids.row(counter).colRange(0,nodes_info.at<int>(i,0)) )
copyTo	softcascade.cpp	/^            (*ptr).hs.copyTo( m_hs.row(counter).colRange(0,nodes_info.at<int>(i,0)) );$/;"	p	file:	signature:( m_hs.row(counter).colRange(0,nodes_info.at<int>(i,0)) )
copyTo	softcascade.cpp	/^            (*ptr).thrs.copyTo( m_thrs.row(counter).colRange(0,nodes_info.at<int>(i,0)) );$/;"	p	file:	signature:( m_thrs.row(counter).colRange(0,nodes_info.at<int>(i,0)) )
copyTo	softcascade.cpp	/^            (*ptr).weights.copyTo( m_weights.row(counter).colRange(0,nodes_info.at<int>(i,0)) );$/;"	p	file:	signature:( m_weights.row(counter).colRange(0,nodes_info.at<int>(i,0)) )
copyTo	softcascade.hpp	/^                t.copyTo( tmp );$/;"	p	signature:( tmp )
copy_offset	main.cpp	/^        samples.resize( origsamples.size()*2); int copy_offset = origsamples.size();$/;"	l
counter	softcascade.cpp	/^    int counter = 0;$/;"	l
counter	softcascade.cpp	/^    int counter=0;$/;"	l
cv::flip	main.cpp	/^            Mat flipped_target; cv::flip( origsamples[i], flipped_target, 1 );$/;"	p	class:cv	file:	signature:( origsamples[i], flipped_target, 1 )
cv::resize	main.cpp	/^                cv::resize( target_obj, target_obj, cv::Size(modelDsBig_width, modelDsBig_height), 0, 0, INTER_AREA);$/;"	p	class:cv	file:	signature:( target_obj, target_obj, cv::Size(modelDsBig_width, modelDsBig_height), 0, 0, INTER_AREA)
depppth	softcascade.cpp	/^    int depppth = m_depth.at<int>(0,m_tree_nodes-1);$/;"	l
det_confs	main.cpp	/^		vector<double> det_confs;$/;"	l
det_opt	main.cpp	/^    detector_opt det_opt;$/;"	l
det_rects	main.cpp	/^		vector<Rect> det_rects;$/;"	l
detectMultiScale	main.cpp	/^		sc.detectMultiScale( input_img, det_rects, det_confs );$/;"	p	file:	signature:( input_img, det_rects, det_confs )
detectMultiScale	main.cpp	/^		sc.detectMultiScale( test_img, det_rects, det_confs );$/;"	p	file:	signature:( test_img, det_rects, det_confs )
detectMultiScale	main.cpp	/^                sc.detectMultiScale( img, target_rects, conf_v );$/;"	p	file:	signature:( img, target_rects, conf_v )
detectMultiScale	main.cpp	/^        sc.detectMultiScale( test_img, re, confs );$/;"	p	file:	signature:( test_img, re, confs )
detectMultiScale	main.cpp	/^        sc.detectMultiScale( test_img, re, confs);$/;"	p	file:	signature:( test_img, re, confs)
detectMultiScale	softcascade.cpp	/^bool softcascade::detectMultiScale( const Mat &image,$/;"	f	class:softcascade	signature:( const Mat &image, vector<Rect> &targets, vector<double> &confidence, int stride, int minSize, int maxSize) const
detectMultiScale	softcascade.hpp	/^        bool detectMultiScale( const Mat &image,                    \/* in : image *\/$/;"	p	class:softcascade	access:public	signature:( const Mat &image, vector<Rect> &targets, vector<double> &confidence, int stride = 4, int minSize = 32, int maxSize = 300) const
end_it	main.cpp	/^	bf::directory_iterator end_it;$/;"	l
end_it	main.cpp	/^        bf::directory_iterator end_it;$/;"	l
end_it	main.cpp	/^        bf::directory_iterator end_it;int number_target = 0;$/;"	l
end_it	main.cpp	/^    bf::directory_iterator end_it;$/;"	l
endl	main.cpp	/^			cout<<"add 'hard example' "<<neg_origsamples.size()<<", keep "<<n1<<" neg examples from previous stage "<<endl;$/;"	l
endl	main.cpp	/^			cout<<"confidence is "<<confs[c]<<endl;$/;"	l
endl	main.cpp	/^			cout<<"img empty, return "<<endl;$/;"	l
endl	main.cpp	/^			cout<<"negative image folder path "<<neg_img_path<<" dose not exist "<<endl;$/;"	l
endl	main.cpp	/^		cout<<"=========== Training Stage No "<<stage<<" ==========="<<endl;$/;"	l
endl	main.cpp	/^		cout<<"Done Stage No "<<stage<<" , time "<<tk.getTimeSec()<<endl<<endl;$/;"	l
endl	main.cpp	/^	cout<<"FP test ... "<<endl;$/;"	l
endl	main.cpp	/^	cout<<"Test FN "<<endl;$/;"	l
endl	main.cpp	/^	cout<<"number of fp is "<<number_of_fp<<endl;$/;"	l
endl	main.cpp	/^            cout<<"check "<<pos_img_path<<"  and "<<pos_gt_path<<endl;$/;"	l
endl	main.cpp	/^            cout<<"pos img or gt path does not exist!"<<endl;$/;"	l
endl	main.cpp	/^        cout<<"------------------------------ RUN "<<c<<" ------------------------------------"<<endl;$/;"	l
endl	main.cpp	/^        cout<<"Train : avg_train_neg_score is "<<avg_train_neg_score<<endl;$/;"	l
endl	main.cpp	/^        cout<<"Train : avg_train_pos_score is "<<avg_train_pos_score<<endl;$/;"	l
endl	main.cpp	/^        cout<<endl;$/;"	l
endl	main.cpp	/^    cout<<"Making negative test data "<<endl;$/;"	l
endl	main.cpp	/^    cout<<"Sampling ..."<<endl;$/;"	l
endl	main.cpp	/^    cout<<"Sampling done "<<endl;$/;"	l
endl	main.cpp	/^    cout<<"Test result on INRIA dataset\\n FP is "<<stat_fp<<" FN is "<<stat_fn<<endl;$/;"	l
endl	main.cpp	/^    cout<<"Test: avg pos score is "<<avg_pos_score<<" avg neg score is "<<avg_neg_score<<endl;$/;"	l
endl	main.cpp	/^    cout<<"fp_v :"<<endl;$/;"	l
endl	main.cpp	/^    cout<<"number of fn is "<<number_of_fn<<endl;$/;"	l
endl	main.cpp	/^    cout<<"number of target is "<<number_of_target<<endl;$/;"	l
endl	main.cpp	/^    cout<<"number of wrong is "<<number_of_wrong<<endl;$/;"	l
endl	main.cpp	/^    cout<<"number_of_fp is "<<number_of_fp<<endl;$/;"	l
endl	main.cpp	/^    cout<<"precision_v :"<<endl;$/;"	l
endl	main.cpp	/^    cout<<"using threads "<<Nthreads<<endl;$/;"	l
endl	main.cpp	/^    cout<<endl;$/;"	l
endl	softcascade.cpp	/^            cout<<"<softcascade::Apply><error> input_data's memory not continuous "<<endl;$/;"	l
endl	softcascade.cpp	/^            cout<<"<softcascade::Combine><error> Adaboost struct is empty .. "<<endl;$/;"	l
endl	softcascade.cpp	/^        cout<<"<softcascade::Apply><error> input_data shoule be continuous ~"<<endl;$/;"	l
endl	softcascade.cpp	/^        cout<<"<softcascade::Apply><error> input_data's size should equ nchannels "<<endl;$/;"	l
endl	softcascade.cpp	/^        cout<<"<softcascade::Load><error> Can not load model file "<<path_to_model<<endl;$/;"	l
endl	softcascade.cpp	/^        cout<<"<softcascade::Save><error> can not open file "<<path_to_model<<" for writing ."<<endl;$/;"	l
endl	softcascade.cpp	/^        cout<<"<softcascade::checkModel><error> Model is empty "<<endl;$/;"	l
endl	softcascade.cpp	/^        cout<<"<softcascade::checkModel><error> Model is not continuous "<<endl;$/;"	l
endl	softcascade.cpp	/^        cout<<"Making model from adaboost structure ..."<<endl;$/;"	l
endl	softcascade.cpp	/^        cout<<"max_number_of_nodes is \\n"<<max_number_of_nodes<<endl;$/;"	l
endl	softcascade.cpp	/^        cout<<"number_of_trees is \\n"<<number_of_trees<<endl;$/;"	l
endl	softcascade.cpp	/^        cout<<"softcascade::Apply><error> unsupported data type, must be one of CV_64F, CV_32F or CV_32S "<<endl;$/;"	l
endl	softcascade.cpp	/^        cout<<"the depth of the trees is "<<m_tree_depth<<endl;$/;"	l
endl	softcascade.cpp	/^        cout<<"tree_nodes is \\n"<<tree_nodes<<endl;$/;"	l
endl	softcascade.cpp	/^    cout<<"Loading Model Done "<<endl;$/;"	l
endl	softcascade.cpp	/^    cout<<"Saving Model Done "<<endl;$/;"	l
endl	softcascade.cpp	/^    cout<<"softcascade : number of trees "<<m_number_of_trees<<endl;$/;"	l
endl	softcascade.hpp	/^                    cout<<"no known data type in Predict() function "<<endl;$/;"	l
endl	softcascade.hpp	/^                cout<<"Data must be continuous is Predict() function"<<endl;$/;"	l
endl	softcascade.hpp	/^                cout<<"Data's empty in Predict() function "<<endl;$/;"	l
endl	softcascade.hpp	/^                cout<<"only single channel is supported in Predict() function "<<endl;$/;"	l
extname	main.cpp	/^            string extname  = bf::extension( s );$/;"	l
extname	main.cpp	/^        string extname  = bf::extension(s);$/;"	l
fea	softcascade.cpp	/^            int fea = m_fids.at<int>( r, c);$/;"	l
feas	main.cpp	/^                vector<Mat> feas;$/;"	l
feas	main.cpp	/^            vector<Mat> feas;$/;"	l
feas	main.cpp	/^        vector<Mat> feas;$/;"	l
feature_height	softcascade.cpp	/^    int feature_height = m_opts.modelDsPad.height\/m_opts.shrink;$/;"	l
feature_width	softcascade.cpp	/^    int feature_width  = m_opts.modelDsPad.width\/m_opts.shrink;  $/;"	l
ff1	main.cpp	/^    feature_Pyramids ff1;$/;"	l
filter	softcascade.hpp	/^	vector<int> filter;					\/* de-correlation filter parameters, eg [5 5]  *\/$/;"	m	struct:cascadeParameter	access:public
final_feature_dim	main.cpp	/^    int final_feature_dim = modelDsPad.width\/n_shrink*modelDsPad.height\/n_shrink*n_channels;$/;"	l
flip	main.cpp	/^            Mat flipped_target; cv::flip( origsamples[i], flipped_target, 1 );$/;"	p	class:cv	file:	signature:( origsamples[i], flipped_target, 1 )
flipped_target	main.cpp	/^            Mat flipped_target; cv::flip( origsamples[i], flipped_target, 1 );$/;"	l
for_test_feat	main.cpp	/^    Mat for_test_feat;$/;"	l
fp_tmp	main.cpp	/^        double fp_tmp = 0;$/;"	l
fp_v	main.cpp	/^        cout<<fp_v[c]<<" ";$/;"	l
fp_v	main.cpp	/^    vector<double> fp_v(number_to_go,0);$/;"	p	file:	signature:(number_to_go,0)
fs	softcascade.cpp	/^    FileStorage fs( path_to_model, FileStorage::WRITE);$/;"	p	file:	signature:( path_to_model, FileStorage::WRITE)
fs	softcascade.cpp	/^    FileStorage fs(path_to_model, FileStorage::READ );$/;"	p	file:	signature:(path_to_model, FileStorage::READ )
fst	main.cpp	/^            FileStorage fst( gt_path_vector[i], FileStorage::READ | FileStorage::FORMAT_XML);$/;"	p	file:	signature:( gt_path_vector[i], FileStorage::READ | FileStorage::FORMAT_XML)
fst	main.cpp	/^        FileStorage fst( gt_path_vector[i], FileStorage::READ | FileStorage::FORMAT_XML);$/;"	p	file:	signature:( gt_path_vector[i], FileStorage::READ | FileStorage::FORMAT_XML)
getFeatureChannelAndPosition	softcascade.cpp	/^bool softcascade::getFeatureChannelAndPosition( const int featureIndex, $/;"	f	class:softcascade	signature:( const int featureIndex, Point & position, int &nchannel) const
getFeatureChannelAndPosition	softcascade.hpp	/^        bool getFeatureChannelAndPosition( const int featureIndex, $/;"	p	class:softcascade	access:private	signature:( const int featureIndex, Point & position, int &nchannel) const
getNumberOfFilesInDir	main.cpp	/^size_t getNumberOfFilesInDir( string in_path )$/;"	f	signature:( string in_path )
getParas	softcascade.cpp	/^cascadeParameter softcascade::getParas() const$/;"	f	class:softcascade	signature:() const
getParas	softcascade.hpp	/^		cascadeParameter getParas() const;$/;"	p	class:softcascade	access:public	signature:() const
gt_path_vector	main.cpp	/^	vector<string> gt_path_vector;$/;"	l
gt_path_vector	main.cpp	/^        vector<string> gt_path_vector;$/;"	l
h	softcascade.cpp	/^            double h=0;$/;"	l
h	softcascade.hpp	/^			double h = 0;$/;"	l
h_f	main.cpp	/^	int h_f = modelDs.height\/shrink;$/;"	l
h_in_data	main.cpp	/^	int h_in_data = in_data[0].rows;$/;"	l
h_ratio	main.cpp	/^                double h_ratio = modelDsBig_height*1.0\/opts.modelDs.height;$/;"	l
i	main.cpp	/^                stringstream ss;ss<<i;string index_string;ss>>index_string;$/;"	l
im	main.cpp	/^            Mat im = imread( image_path_vector[i]);$/;"	l
image_path_vector	main.cpp	/^        vector<string> image_path_vector;$/;"	l
image_path_vector	main.cpp	/^    vector<string> image_path_vector;$/;"	l
img	main.cpp	/^			Mat img = imread( neg_paths[c] );$/;"	l
index_string	main.cpp	/^                    stringstream ss;ss<<c;string index_string;ss>>index_string;$/;"	l
index_string	main.cpp	/^                stringstream ss;ss<<i;string index_string;ss>>index_string;$/;"	l
infos	softcascade.hpp	/^	string infos;						\/* other informations~~ *\/$/;"	m	struct:cascadeParameter	access:public
input_img	main.cpp	/^		Mat input_img = imread( image_path_vector[c]);$/;"	l
insert	main.cpp	/^            accu_neg.insert( accu_neg.begin(), neg_origsamples.begin(), neg_origsamples.end());    $/;"	p	file:	signature:( accu_neg.begin(), neg_origsamples.begin(), neg_origsamples.end())
insert	main.cpp	/^            accu_neg.insert( accu_neg.begin(), neg_previousSamples.begin(), neg_previousSamples.end());$/;"	p	file:	signature:( accu_neg.begin(), neg_previousSamples.begin(), neg_previousSamples.end())
intersect	main.cpp	/^	Rect intersect = r1 & r2;$/;"	l
isMatched_l	main.cpp	/^		vector<bool> isMatched_l( det_rects.size(), false);$/;"	p	file:	signature:( det_rects.size(), false)
isMatched_r	main.cpp	/^		vector<bool> isMatched_r( target_rects.size(), false);$/;"	p	file:	signature:( target_rects.size(), false)
isSameTarget	main.cpp	/^bool isSameTarget( Rect r1, Rect r2)$/;"	f	signature:( Rect r1, Rect r2)
m_child	softcascade.cpp	/^    fs<<"m_child"<<m_child;$/;"	l
m_child	softcascade.cpp	/^    fs["m_child"]>>m_child;$/;"	l
m_child	softcascade.hpp	/^		Mat m_child;						\/* nxK 32S child index for each node *\/$/;"	m	class:softcascade	access:private
m_debug	softcascade.hpp	/^		bool m_debug;						\/* wanna output? *\/$/;"	m	class:softcascade	access:private
m_depth	softcascade.cpp	/^    fs<<"m_depth"<<m_depth;$/;"	l
m_depth	softcascade.cpp	/^    fs["m_depth"] >> m_depth;$/;"	l
m_depth	softcascade.hpp	/^		Mat m_depth;						\/* nxK 32S depth of node*\/$/;"	m	class:softcascade	access:private
m_feature_gen	softcascade.hpp	/^        feature_Pyramids m_feature_gen;     \/* feature generator *\/$/;"	m	class:softcascade	access:private
m_fids	softcascade.cpp	/^    fs<<"m_fids"<<m_fids;$/;"	l
m_fids	softcascade.cpp	/^    fs["m_fids"]>>m_fids;$/;"	l
m_fids	softcascade.hpp	/^		Mat m_fids;							\/* nxK 32S feature index for each node , n -> number of trees, K -> number of nodes*\/$/;"	m	class:softcascade	access:private
m_hs	softcascade.cpp	/^    fs<<"m_hs"<<m_hs;$/;"	l
m_hs	softcascade.cpp	/^    fs["m_hs"]>>m_hs;$/;"	l
m_hs	softcascade.hpp	/^		Mat m_hs;							\/* nxK 64F log ratio (.5*log(p\/(1-p)) at each node  *\/$/;"	m	class:softcascade	access:private
m_nodes	softcascade.cpp	/^    fs<<"m_nodes"<<m_nodes;$/;"	l
m_nodes	softcascade.cpp	/^    fs["m_nodes"]>>m_nodes;$/;"	l
m_nodes	softcascade.hpp	/^		Mat m_nodes;						\/* nx1 32S number of nodes of each tree *\/$/;"	m	class:softcascade	access:private
m_number_of_trees	softcascade.cpp	/^    fs<<"m_number_of_trees"<<m_number_of_trees;$/;"	l
m_number_of_trees	softcascade.cpp	/^    fs["m_number_of_trees"]>>m_number_of_trees;$/;"	l
m_number_of_trees	softcascade.hpp	/^		int m_number_of_trees;				\/* . *\/$/;"	m	class:softcascade	access:private
m_opts	softcascade.hpp	/^		cascadeParameter m_opts;            \/* detectot options  *\/$/;"	m	class:softcascade	access:private
m_thrs	softcascade.cpp	/^    fs<<"m_thrs"<<m_thrs;$/;"	l
m_thrs	softcascade.cpp	/^    fs["m_thrs"]>>m_thrs;$/;"	l
m_thrs	softcascade.hpp	/^		Mat m_thrs;							\/* nxK 64F thresholds for each node *\/$/;"	m	class:softcascade	access:private
m_tree_depth	softcascade.hpp	/^		int m_tree_depth;					\/* depth of all leaf nodes (or 0 if leaf depth varies) *\/$/;"	m	class:softcascade	access:private
m_tree_nodes	softcascade.cpp	/^    fs<<"m_tree_nodes"<<m_tree_nodes;$/;"	l
m_tree_nodes	softcascade.cpp	/^    fs["m_tree_nodes"]>>m_tree_nodes;$/;"	l
m_tree_nodes	softcascade.hpp	/^		int m_tree_nodes;					\/* if all the tree have the same structure, this will be the number of the nodes of each tree, otherwise -1*\/$/;"	m	class:softcascade	access:private
m_weights	softcascade.cpp	/^    fs<<"m_weights"<<m_weights;$/;"	l
m_weights	softcascade.cpp	/^    fs["m_weights"]>>m_weights;$/;"	l
m_weights	softcascade.hpp	/^		Mat m_weights;						\/* nxK 64F total sample weight at each node *\/$/;"	m	class:softcascade	access:private
main	main.cpp	/^int main( int argc, char** argv)$/;"	f	signature:( int argc, char** argv)
main	test.cpp	/^int main( int argc, char** argv)$/;"	f	signature:( int argc, char** argv)
makeTrainData	main.cpp	/^void makeTrainData( vector<Mat> &in_data, Mat &output_data, Size modelDs, int shrink)$/;"	f	signature:( vector<Mat> &in_data, Mat &output_data, Size modelDs, int shrink)
matched	main.cpp	/^		int matched = 0;$/;"	l
max_number_of_nodes	softcascade.cpp	/^    int max_number_of_nodes = 0;$/;"	l
modelDs	softcascade.hpp	/^	Size modelDs;						\/* model height+width without padding (eg [100 41]) *\/$/;"	m	struct:cascadeParameter	access:public
modelDsBig_height	main.cpp	/^                int modelDsBig_height = std::max( 8*opts.shrink,opts.modelDsPad.height)+std::max(2,64\/opts.shrink)*opts.shrink;$/;"	l
modelDsBig_width	main.cpp	/^                int modelDsBig_width = std::max( 8*opts.shrink, opts.modelDsPad.width)+std::max(2, 64\/opts.shrink)*opts.shrink;$/;"	l
modelDsPad	main.cpp	/^    Size modelDsPad = cas_para.modelDsPad;$/;"	l
modelDsPad	softcascade.hpp	/^	Size modelDsPad;					\/* model height+width with padding (eg [128 64])*\/$/;"	m	struct:cascadeParameter	access:public
modelH_fit	softcascade.cpp	/^    const int modelH_fit  = opts.modelDs.height;$/;"	l
modelH_shift	softcascade.cpp	/^    const int modelH_shift= (modelHeight- opts.modelDs.height)\/2 - opts.pad.height;$/;"	l
modelHeight	softcascade.cpp	/^    const int modelHeight = opts.modelDsPad.height;$/;"	l
modelW_fit	softcascade.cpp	/^    const int modelW_fit  = opts.modelDs.width;$/;"	l
modelW_shift	softcascade.cpp	/^    const int modelW_shift= (modelWidth - opts.modelDs.width)\/2 - opts.pad.width;$/;"	l
modelWidth	softcascade.cpp	/^    const int modelWidth  = opts.modelDsPad.width;$/;"	l
mr_tmp	main.cpp	/^        double mr_tmp = 0;$/;"	l
myrandom	main.cpp	/^int myrandom (int i) { return std::rand()%i;}$/;"	f	signature:(int i)
n1	main.cpp	/^            int n1 = std::max(cas_para.nAccNeg,cas_para.nNeg)-neg_origsamples.size();   \/* how many will be save from previous stage *\/$/;"	l
nAccNeg	softcascade.hpp	/^	int nAccNeg;						\/* [10000] max number of neg windows to accumulate*\/$/;"	m	struct:cascadeParameter	access:public
nNeg	softcascade.hpp	/^	int nNeg;							\/* [5000] max number of neg windows to sample*\/$/;"	m	struct:cascadeParameter	access:public
nPerNeg	softcascade.hpp	/^	int nPerNeg;						\/* [25]  max number of neg windows to sample per image*\/$/;"	m	struct:cascadeParameter	access:public
nPos	softcascade.hpp	/^	int nPos;							\/* [-1 -> inf] max number of pos windows to sample *\/						$/;"	m	struct:cascadeParameter	access:public
nWeaks	softcascade.hpp	/^	vector<int> nWeaks;					\/* [128] vector defining number weak clfs per stagemodel eg[64 128 256 1024]*\/$/;"	m	struct:cascadeParameter	access:public
n_c	softcascade.cpp	/^            Point position; int n_c;$/;"	l
n_channels	main.cpp	/^    int n_channels = cas_para.nchannels;$/;"	l
n_height	softcascade.cpp	/^    int n_height = (int) ceil((in_height*shrink-modelHeight+1)\/stride);$/;"	l
n_shrink	main.cpp	/^    int n_shrink = cas_para.shrink;$/;"	l
n_width	softcascade.cpp	/^    int n_width  = (int) ceil((in_width*shrink-modelWidth+1)\/stride);$/;"	l
nchannels	softcascade.cpp	/^    const int nchannels   = opts.nchannels;$/;"	l
nchannels	softcascade.hpp	/^    int    nchannels;                   \/* ----------> number of channels, usually 1 *\/$/;"	m	struct:cascadeParameter	access:public
negImgDir	softcascade.hpp	/^    string negImgDir;                   \/* negative image directory *\/$/;"	m	struct:cascadeParameter	access:public
neg_img_dir	main.cpp	/^	bf::path neg_img_dir( testset_neg_path );$/;"	p	file:	signature:( testset_neg_path )
neg_img_path	main.cpp	/^		bf::path neg_img_path(opts.negImgDir);$/;"	p	file:	signature:(opts.negImgDir)
neg_origsamples	main.cpp	/^    vector<Mat> neg_origsamples;$/;"	l
neg_paths	main.cpp	/^		vector<string> neg_paths;$/;"	l
neg_previousSamples	main.cpp	/^    vector<Mat> neg_previousSamples;$/;"	l
neg_samples	main.cpp	/^    vector<Mat> neg_samples;$/;"	l
neg_test_data	main.cpp	/^    Mat neg_test_data = Mat::zeros( final_feature_dim, test_neg_orig.size(), CV_32F );$/;"	l
neg_train_data	main.cpp	/^    Mat neg_train_data;$/;"	l
nodes_info	softcascade.cpp	/^        Mat nodes_info = ads[c].getNodes();$/;"	l
number_channels	softcascade.cpp	/^    int number_channels = m_opts.nchannels;$/;"	l
number_of_fn	main.cpp	/^	int number_of_fn = 0;$/;"	l
number_of_fp	main.cpp	/^	int number_of_fp = 0;$/;"	l
number_of_neg_images	main.cpp	/^		int number_of_neg_images = 	getNumberOfFilesInDir( opts.negImgDir );$/;"	l
number_of_neg_images	main.cpp	/^	int number_of_neg_images = getNumberOfFilesInDir( testset_neg_path );$/;"	l
number_of_nodes	softcascade.cpp	/^    const int number_of_nodes = fids.cols;$/;"	l
number_of_pos_images	main.cpp	/^	int number_of_pos_images = getNumberOfFilesInDir( testset_pos_image_path );$/;"	l
number_of_target	main.cpp	/^    int number_of_target = 0;$/;"	l
number_of_trees	softcascade.cpp	/^    const int number_of_trees = fids.rows;$/;"	l
number_of_trees	softcascade.cpp	/^    int number_of_trees = 0;$/;"	l
number_of_wrong	main.cpp	/^	int number_of_wrong = 0;$/;"	l
number_pos_img	main.cpp	/^        int number_pos_img = getNumberOfFilesInDir( opts.posGtDir );$/;"	l
number_target	main.cpp	/^        bf::directory_iterator end_it;int number_target = 0;$/;"	l
number_target_per_image	main.cpp	/^		int number_target_per_image = opts.nPerNeg;$/;"	l
number_to_go	main.cpp	/^    int number_to_go = 5;$/;"	l
number_to_sample	main.cpp	/^    int number_to_sample = 0;$/;"	l
opts	main.cpp	/^    cascadeParameter opts = sc.getParas();$/;"	l
pBoost_nweaks	softcascade.hpp	/^	int pBoost_nweaks;					\/* parameters for boosting *\/$/;"	m	struct:cascadeParameter	access:public
pBoost_pTree	softcascade.hpp	/^	tree_para pBoost_pTree;				\/* parameters for boosting *\/$/;"	m	struct:cascadeParameter	access:public
pad	softcascade.hpp	/^    Size pad;                           \/* ----------> get it from feature generator *\/$/;"	m	struct:cascadeParameter	access:public
par_for_test	main.cpp	/^    cascadeParameter par_for_test = sc.getParas();$/;"	l
pathname	main.cpp	/^            string pathname = file_iter->path().string();$/;"	l
pathname	main.cpp	/^        string pathname = file_iter->path().string();$/;"	l
posGtDir	softcascade.hpp	/^    string posGtDir;                    \/* positive groundtruth directory *\/$/;"	m	struct:cascadeParameter	access:public
posImgDir	softcascade.hpp	/^    string posImgDir;                   \/* positive image directory *\/$/;"	m	struct:cascadeParameter	access:public
pos_gt_path	main.cpp	/^        bf::path pos_gt_path( opts.posGtDir );$/;"	p	file:	signature:( opts.posGtDir )
pos_img_dir	main.cpp	/^	bf::path pos_img_dir(testset_pos_image_path);$/;"	p	file:	signature:(testset_pos_image_path)
pos_img_path	main.cpp	/^        bf::path pos_img_path( opts.posImgDir );$/;"	p	file:	signature:( opts.posImgDir )
pos_origsamples	main.cpp	/^    vector<Mat> pos_origsamples;$/;"	l
pos_samples	main.cpp	/^    vector<Mat> pos_samples;$/;"	l
pos_test_data	main.cpp	/^    Mat pos_test_data = Mat::zeros( final_feature_dim, test_pos_all.size(), CV_32F);$/;"	l
pos_train_data	main.cpp	/^    Mat pos_train_data;$/;"	l
position	softcascade.cpp	/^                    int position = 0;$/;"	l
position	softcascade.cpp	/^            Point position; int n_c;$/;"	l
position	softcascade.hpp	/^					int position   = 0;$/;"	l
position	softcascade.hpp	/^					int position = 0;$/;"	l
pp	main.cpp	/^            float *pp = ptr + j*w_in_data;$/;"	l
pre_neg_score	main.cpp	/^        Mat pre_neg_score;$/;"	l
pre_pos_score	main.cpp	/^        Mat pre_pos_score;$/;"	l
precision_v	main.cpp	/^        cout<<precision_v[c]<<" ";$/;"	l
precision_v	main.cpp	/^    vector<double> precision_v(number_to_go,0);$/;"	p	file:	signature:(number_to_go,0)
probe_feature_starter	softcascade.cpp	/^            const T *probe_feature_starter = input_data + (c*stride\/shrink)*in_width + (w*stride\/shrink);$/;"	l
ptr	main.cpp	/^        float *ptr=(float*)in_data[c].ptr() + (h_in_data - h_f)\/2*w_in_data + (w_in_data - w_f)\/2;$/;"	l
ptr	softcascade.cpp	/^            const biTree *ptr = bts[i].getTree();       $/;"	l
push_back	main.cpp	/^			neg_paths.push_back( pathname );$/;"	p	file:	signature:( pathname )
push_back	main.cpp	/^                    origsamples.push_back( target_obj );$/;"	p	file:	signature:( target_obj )
push_back	main.cpp	/^            gt_path_vector.push_back(opts.posGtDir + basename + ".txt");$/;"	p	file:	signature:(opts.posGtDir + basename + Ó)
push_back	main.cpp	/^            image_path_vector.push_back( pathname );$/;"	p	file:	signature:( pathname )
push_back	main.cpp	/^        image_path_vector.push_back( pathname );$/;"	p	file:	signature:( pathname )
push_back	main.cpp	/^        t_v.push_back( ab );$/;"	p	file:	signature:( ab )
push_back	softcascade.cpp	/^                confidence.push_back( h );$/;"	p	file:	signature:( h )
push_back	softcascade.cpp	/^                results.push_back( tmp );$/;"	p	file:	signature:( tmp )
push_back	softcascade.cpp	/^            confidence.push_back( t_conf[i]);$/;"	p	file:	signature:( t_conf[i])
push_back	softcascade.cpp	/^            targets.push_back( s );$/;"	p	file:	signature:( s )
random_shuffle	main.cpp	/^		std::random_shuffle( neg_paths.begin(), neg_paths.end(),myrandom);$/;"	p	class:std	file:	signature:( neg_paths.begin(), neg_paths.end(),myrandom)
random_shuffle	main.cpp	/^                std::random_shuffle( neg_previousSamples.begin(), neg_previousSamples.end(), myrandom);$/;"	p	class:std	file:	signature:( neg_previousSamples.begin(), neg_previousSamples.end(), myrandom)
random_shuffle	main.cpp	/^                std::random_shuffle( target_rects.begin(), target_rects.end() , myrandom);$/;"	p	class:std	file:	signature:( target_rects.begin(), target_rects.end() , myrandom)
random_shuffle	main.cpp	/^            std::random_shuffle( origsamples.begin(), origsamples.end(), myrandom);$/;"	p	class:std	file:	signature:( origsamples.begin(), origsamples.end(), myrandom)
re	main.cpp	/^        vector<Rect> re;vector<double> confs;$/;"	l
release	main.cpp	/^            fst.release();$/;"	p	file:	signature:()
release	main.cpp	/^        fst.release();$/;"	p	file:	signature:()
release	softcascade.cpp	/^    fs.release();$/;"	p	file:	signature:()
reserve	main.cpp	/^            accu_neg.reserve( neg_previousSamples.size() + neg_origsamples.size() );$/;"	p	file:	signature:( neg_previousSamples.size() + neg_origsamples.size() )
reset	main.cpp	/^	tk.reset();tk.start();$/;"	p	file:	signature:()
reset	main.cpp	/^        tk.reset();tk.start();$/;"	p	file:	signature:()
resize	main.cpp	/^					target_rects.resize( number_target_per_image );$/;"	p	file:	signature:( number_target_per_image )
resize	main.cpp	/^                    target_rects.resize( number_target_per_image);$/;"	p	file:	signature:( number_target_per_image)
resize	main.cpp	/^                cv::resize( target_obj, target_obj, cv::Size(modelDsBig_width, modelDsBig_height), 0, 0, INTER_AREA);$/;"	p	class:cv	file:	signature:( target_obj, target_obj, cv::Size(modelDsBig_width, modelDsBig_height), 0, 0, INTER_AREA)
resize	main.cpp	/^                neg_previousSamples.resize( n1 );$/;"	p	file:	signature:( n1 )
resize	main.cpp	/^            origsamples.resize( number_to_sample );$/;"	p	file:	signature:( number_to_sample )
resize	main.cpp	/^            origsamples.resize( number_to_sample);$/;"	p	file:	signature:( number_to_sample)
resize	main.cpp	/^        samples.resize( origsamples.size()*2); int copy_offset = origsamples.size();$/;"	p	file:	signature:( origsamples.size()*2)
resize	softcascade.cpp	/^    vector<Mat> v_features;v_features.resize( number_channels);$/;"	p	file:	signature:( number_channels)
runTrainAndTest	main.cpp	/^int runTrainAndTest( double &out_miss_rate, double &out_fp_per_image)$/;"	f	signature:( double &out_miss_rate, double &out_fp_per_image)
s	main.cpp	/^		bf::path s = *(file_iter);$/;"	l
s	main.cpp	/^            bf::path s = *(file_iter);$/;"	l
s	softcascade.cpp	/^            Rect s( t_tar[i].x\/appro_scales[c], t_tar[i].y\/appro_scales[c], t_tar[i].width\/scale_w[c], t_tar[i].height\/scale_h[c]  );$/;"	p	file:	signature:( t_tar[i].x/appro_scales[c], t_tar[i].y/appro_scales[c], t_tar[i].width/scale_w[c], t_tar[i].height/scale_h[c] )
sampleWins	main.cpp	/^bool sampleWins(    const softcascade &sc, 	    \/*  in: detector *\/$/;"	f	signature:( const softcascade &sc, int stage, bool isPositive, vector<Mat> &samples, vector<Mat> &origsamples)
save_img	main.cpp	/^                    Mat save_img = cropImage( test_img, det_rects[c]);$/;"	l
save_img	main.cpp	/^                    Mat save_img = cropImage( test_img, target_rects[c] );$/;"	l
save_img	main.cpp	/^                Mat save_img = cropImage( input_img, det_rects[i]);$/;"	l
save_path	main.cpp	/^                    string save_path = "pos_fn\/"+basename+"_"+index_string+".jpg";$/;"	l
save_path	main.cpp	/^                    string save_path = "pos_fp\/"+basename+"_"+index_string+".jpg";$/;"	l
save_path	main.cpp	/^                string save_path = "neg_fp\/"+basename+"_"+index_string+".jpg";$/;"	l
sc	main.cpp	/^		sc.Predict( (float*)for_test_feat.data, score );$/;"	p	file:	signature:(float*)for_test_feat.data, score 
sc	main.cpp	/^        sc.Predict( (float*)for_test_feat.data, score);$/;"	p	file:	signature:(float*)for_test_feat.data, score
sc	main.cpp	/^    softcascade sc;$/;"	l
sc	test.cpp	/^    softcascade sc;$/;"	l
scale_h	softcascade.cpp	/^    vector<double> scale_h;$/;"	l
scale_w	softcascade.cpp	/^    vector<double> scale_w;$/;"	l
score	main.cpp	/^        double score = 0;$/;"	l
score	softcascade.hpp	/^                double score = 0;$/;"	l
setDebug	main.cpp	/^    sc.setDebug( false);$/;"	p	file:	signature:( false)
setDebug	softcascade.cpp	/^void softcascade::setDebug( bool m_d )$/;"	f	class:softcascade	signature:( bool m_d )
setDebug	softcascade.hpp	/^        void setDebug( bool m_d );$/;"	p	class:softcascade	access:public	signature:( bool m_d )
setFeatureGen	main.cpp	/^    sc.setFeatureGen( ff1 );$/;"	p	file:	signature:( ff1 )
setFeatureGen	softcascade.hpp	/^        void setFeatureGen( const feature_Pyramids &in_fea_gen )$/;"	f	class:softcascade	access:public	signature:( const feature_Pyramids &in_fea_gen )
setParas	main.cpp	/^    sc.setParas( cas_para);$/;"	p	file:	signature:( cas_para)
setParas	main.cpp	/^    sc.setParas( par_for_test);$/;"	p	file:	signature:( par_for_test)
setParas	softcascade.cpp	/^void softcascade::setParas( const cascadeParameter &in_par )$/;"	f	class:softcascade	signature:( const cascadeParameter &in_par )
setParas	softcascade.hpp	/^        void setParas( const cascadeParameter &in_par );$/;"	p	class:softcascade	access:public	signature:( const cascadeParameter &in_par )
setTreeDepth	softcascade.cpp	/^bool softcascade::setTreeDepth()$/;"	f	class:softcascade	signature:()
setTreeDepth	softcascade.hpp	/^		bool setTreeDepth();$/;"	p	class:softcascade	access:private	signature:()
shrink	softcascade.cpp	/^    const int shrink      = opts.shrink;$/;"	l
shrink	softcascade.hpp	/^	int shrink;							\/* ----------> should be provided by the chnPyramid *\/$/;"	m	struct:cascadeParameter	access:public
softcascade	softcascade.hpp	/^class softcascade$/;"	c
softcascade::Apply	softcascade.cpp	/^bool softcascade::Apply( const Mat &input_image,        \/*  in: !!! image !!! *\/$/;"	f	class:softcascade	signature:( const Mat &input_image, vector<Rect> &results, vector<double> &confidence)
softcascade::Apply	softcascade.cpp	/^bool softcascade::Apply( const vector<Mat> &input_data,      \/*  in: channels feature which has a continuous mem like nchannelsxfeature_widthxfeature_height*\/$/;"	f	class:softcascade	signature:( const vector<Mat> &input_data, vector<Rect> &results, vector<double> &confidence) const
softcascade::Apply	softcascade.hpp	/^		bool Apply( const vector<Mat> &input_data,		\/*  in: channel features, input_data.size() == nchannels *\/$/;"	p	class:softcascade	access:public	signature:( const vector<Mat> &input_data, vector<Rect> &results, vector<double> &confidence) const
softcascade::Apply	softcascade.hpp	/^        bool Apply( const Mat &input_image,             \/*  in: !!! image !!! *\/$/;"	p	class:softcascade	access:public	signature:( const Mat &input_image, vector<Rect> &results, vector<double> &confidence)
softcascade::Combine	softcascade.cpp	/^bool softcascade::Combine(vector<Adaboost> &ads )$/;"	f	class:softcascade	signature:(vector<Adaboost> &ads )
softcascade::Combine	softcascade.hpp	/^		bool Combine( vector<Adaboost> &ads );$/;"	p	class:softcascade	access:public	signature:( vector<Adaboost> &ads )
softcascade::Load	softcascade.cpp	/^bool softcascade::Load( string path_to_model )      \/* in : path of the model, shoule be a xml file saved by opencv FileStorage *\/$/;"	f	class:softcascade	signature:( string path_to_model )
softcascade::Load	softcascade.hpp	/^		bool Load( string path_to_model );		\/* in : path of the model, shoule be a xml file saved by opencv FileStorage *\/$/;"	p	class:softcascade	access:public	signature:( string path_to_model )
softcascade::Predict	softcascade.hpp	/^		template < typename T> bool Predict(  const T *data,            \/* in : test data, must be continuous in memory *\/$/;"	f	class:softcascade	access:public	signature:( const T *data, double &score) const
softcascade::Predict	softcascade.hpp	/^        bool Predict( const Mat &testData,              \/* in : featureDim x numberOfSamples *\/$/;"	f	class:softcascade	access:public	signature:( const Mat &testData, Mat &confidence)
softcascade::Save	softcascade.cpp	/^bool softcascade::Save( string path_to_model )      \/*  in: where to save the model, models is saved by opencv FileStorage *\/$/;"	f	class:softcascade	signature:( string path_to_model )
softcascade::Save	softcascade.hpp	/^		bool Save( string path_to_model );		\/*  in: where to save the model, models is saved by opencv FileStorage *\/$/;"	p	class:softcascade	access:public	signature:( string path_to_model )
softcascade::at	softcascade.hpp	/^                confidence.at<double>(c,0) = score;$/;"	p	signature:(c,0)
softcascade::checkModel	softcascade.cpp	/^bool softcascade::checkModel() const$/;"	f	class:softcascade	signature:() const
softcascade::checkModel	softcascade.hpp	/^		bool checkModel() const;$/;"	p	class:softcascade	access:public	signature:() const
softcascade::copyTo	softcascade.hpp	/^                t.copyTo( tmp );$/;"	p	signature:( tmp )
softcascade::detectMultiScale	softcascade.cpp	/^bool softcascade::detectMultiScale( const Mat &image,$/;"	f	class:softcascade	signature:( const Mat &image, vector<Rect> &targets, vector<double> &confidence, int stride, int minSize, int maxSize) const
softcascade::detectMultiScale	softcascade.hpp	/^        bool detectMultiScale( const Mat &image,                    \/* in : image *\/$/;"	p	class:softcascade	access:public	signature:( const Mat &image, vector<Rect> &targets, vector<double> &confidence, int stride = 4, int minSize = 32, int maxSize = 300) const
softcascade::endl	softcascade.hpp	/^                    cout<<"no known data type in Predict() function "<<endl;$/;"	l
softcascade::endl	softcascade.hpp	/^                cout<<"Data must be continuous is Predict() function"<<endl;$/;"	l
softcascade::endl	softcascade.hpp	/^                cout<<"Data's empty in Predict() function "<<endl;$/;"	l
softcascade::endl	softcascade.hpp	/^                cout<<"only single channel is supported in Predict() function "<<endl;$/;"	l
softcascade::getFeatureChannelAndPosition	softcascade.cpp	/^bool softcascade::getFeatureChannelAndPosition( const int featureIndex, $/;"	f	class:softcascade	signature:( const int featureIndex, Point & position, int &nchannel) const
softcascade::getFeatureChannelAndPosition	softcascade.hpp	/^        bool getFeatureChannelAndPosition( const int featureIndex, $/;"	p	class:softcascade	access:private	signature:( const int featureIndex, Point & position, int &nchannel) const
softcascade::getParas	softcascade.cpp	/^cascadeParameter softcascade::getParas() const$/;"	f	class:softcascade	signature:() const
softcascade::getParas	softcascade.hpp	/^		cascadeParameter getParas() const;$/;"	p	class:softcascade	access:public	signature:() const
softcascade::h	softcascade.hpp	/^			double h = 0;$/;"	l
softcascade::m_child	softcascade.hpp	/^		Mat m_child;						\/* nxK 32S child index for each node *\/$/;"	m	class:softcascade	access:private
softcascade::m_debug	softcascade.hpp	/^		bool m_debug;						\/* wanna output? *\/$/;"	m	class:softcascade	access:private
softcascade::m_depth	softcascade.hpp	/^		Mat m_depth;						\/* nxK 32S depth of node*\/$/;"	m	class:softcascade	access:private
softcascade::m_feature_gen	softcascade.hpp	/^        feature_Pyramids m_feature_gen;     \/* feature generator *\/$/;"	m	class:softcascade	access:private
softcascade::m_fids	softcascade.hpp	/^		Mat m_fids;							\/* nxK 32S feature index for each node , n -> number of trees, K -> number of nodes*\/$/;"	m	class:softcascade	access:private
softcascade::m_hs	softcascade.hpp	/^		Mat m_hs;							\/* nxK 64F log ratio (.5*log(p\/(1-p)) at each node  *\/$/;"	m	class:softcascade	access:private
softcascade::m_nodes	softcascade.hpp	/^		Mat m_nodes;						\/* nx1 32S number of nodes of each tree *\/$/;"	m	class:softcascade	access:private
softcascade::m_number_of_trees	softcascade.hpp	/^		int m_number_of_trees;				\/* . *\/$/;"	m	class:softcascade	access:private
softcascade::m_opts	softcascade.hpp	/^		cascadeParameter m_opts;            \/* detectot options  *\/$/;"	m	class:softcascade	access:private
softcascade::m_thrs	softcascade.hpp	/^		Mat m_thrs;							\/* nxK 64F thresholds for each node *\/$/;"	m	class:softcascade	access:private
softcascade::m_tree_depth	softcascade.hpp	/^		int m_tree_depth;					\/* depth of all leaf nodes (or 0 if leaf depth varies) *\/$/;"	m	class:softcascade	access:private
softcascade::m_tree_nodes	softcascade.hpp	/^		int m_tree_nodes;					\/* if all the tree have the same structure, this will be the number of the nodes of each tree, otherwise -1*\/$/;"	m	class:softcascade	access:private
softcascade::m_weights	softcascade.hpp	/^		Mat m_weights;						\/* nxK 64F total sample weight at each node *\/$/;"	m	class:softcascade	access:private
softcascade::position	softcascade.hpp	/^					int position   = 0;$/;"	l
softcascade::position	softcascade.hpp	/^					int position = 0;$/;"	l
softcascade::score	softcascade.hpp	/^                double score = 0;$/;"	l
softcascade::setDebug	softcascade.cpp	/^void softcascade::setDebug( bool m_d )$/;"	f	class:softcascade	signature:( bool m_d )
softcascade::setDebug	softcascade.hpp	/^        void setDebug( bool m_d );$/;"	p	class:softcascade	access:public	signature:( bool m_d )
softcascade::setFeatureGen	softcascade.hpp	/^        void setFeatureGen( const feature_Pyramids &in_fea_gen )$/;"	f	class:softcascade	access:public	signature:( const feature_Pyramids &in_fea_gen )
softcascade::setParas	softcascade.cpp	/^void softcascade::setParas( const cascadeParameter &in_par )$/;"	f	class:softcascade	signature:( const cascadeParameter &in_par )
softcascade::setParas	softcascade.hpp	/^        void setParas( const cascadeParameter &in_par );$/;"	p	class:softcascade	access:public	signature:( const cascadeParameter &in_par )
softcascade::setTreeDepth	softcascade.cpp	/^bool softcascade::setTreeDepth()$/;"	f	class:softcascade	signature:()
softcascade::setTreeDepth	softcascade.hpp	/^		bool setTreeDepth();$/;"	p	class:softcascade	access:private	signature:()
softcascade::t	softcascade.hpp	/^                Mat t = testData.col(c);$/;"	l
softcascade::t_child	softcascade.hpp	/^					const int *t_child   = m_child.ptr<int>(c);$/;"	l
softcascade::t_child	softcascade.hpp	/^					const int *t_child   = m_child.ptr<int>(t);$/;"	l
softcascade::t_fids	softcascade.hpp	/^					const int *t_fids    = m_fids.ptr<int>(c);$/;"	l
softcascade::t_fids	softcascade.hpp	/^					const int *t_fids    = m_fids.ptr<int>(t);$/;"	l
softcascade::t_hs	softcascade.hpp	/^					const double *t_hs   = m_hs.ptr<double>(c);$/;"	l
softcascade::t_hs	softcascade.hpp	/^					const double *t_hs   = m_hs.ptr<double>(t);$/;"	l
softcascade::t_thrs	softcascade.hpp	/^					const double *t_thrs = m_thrs.ptr<double>(c);$/;"	l
softcascade::t_thrs	softcascade.hpp	/^					const double *t_thrs = m_thrs.ptr<double>(t);$/;"	l
softcascade::tmp	softcascade.hpp	/^            Mat tmp;        \/* copy each vector into it, since opencv matrix is store by rows, *column* is not continuous in memory(except single column) *\/$/;"	l
softcascade::visulizeFeature	softcascade.cpp	/^void softcascade::visulizeFeature()$/;"	f	class:softcascade	signature:()
softcascade::visulizeFeature	softcascade.hpp	/^        void visulizeFeature();$/;"	p	class:softcascade	access:private	signature:()
srand	main.cpp	/^    std::srand ( unsigned ( std::time(0) ) );$/;"	p	class:std	file:	signature:( unsigned ( std::time(0) ) )
ss	main.cpp	/^			stringstream ss; ss<<confs[c];string conf_string;ss>>conf_string;$/;"	l
ss	main.cpp	/^                    stringstream ss;ss<<c;string index_string;ss>>index_string;$/;"	l
ss	main.cpp	/^                stringstream ss;ss<<i;string index_string;ss>>index_string;$/;"	l
ss	main.cpp	/^        stringstream ss;ss<<stage;string stage_index;ss>>stage_index;$/;"	l
stage	main.cpp	/^        stringstream ss;ss<<stage;string stage_index;ss>>stage_index;$/;"	l
stage_index	main.cpp	/^        stringstream ss;ss<<stage;string stage_index;ss>>stage_index;$/;"	l
start	main.cpp	/^	tk.reset();tk.start();$/;"	p	file:	signature:()
start	main.cpp	/^        tk.reset();tk.start();$/;"	p	file:	signature:()
stat_fn	main.cpp	/^    double stat_fn = 0;$/;"	l
stat_fp	main.cpp	/^    double stat_fp = 0;$/;"	l
std::random_shuffle	main.cpp	/^		std::random_shuffle( neg_paths.begin(), neg_paths.end(),myrandom);$/;"	p	class:std	file:	signature:( neg_paths.begin(), neg_paths.end(),myrandom)
std::random_shuffle	main.cpp	/^                std::random_shuffle( neg_previousSamples.begin(), neg_previousSamples.end(), myrandom);$/;"	p	class:std	file:	signature:( neg_previousSamples.begin(), neg_previousSamples.end(), myrandom)
std::random_shuffle	main.cpp	/^                std::random_shuffle( target_rects.begin(), target_rects.end() , myrandom);$/;"	p	class:std	file:	signature:( target_rects.begin(), target_rects.end() , myrandom)
std::random_shuffle	main.cpp	/^            std::random_shuffle( origsamples.begin(), origsamples.end(), myrandom);$/;"	p	class:std	file:	signature:( origsamples.begin(), origsamples.end(), myrandom)
std::srand	main.cpp	/^    std::srand ( unsigned ( std::time(0) ) );$/;"	p	class:std	file:	signature:( unsigned ( std::time(0) ) )
stop	main.cpp	/^		tk.stop();$/;"	p	file:	signature:()
stop	main.cpp	/^	tk.stop();$/;"	p	file:	signature:()
stop	main.cpp	/^        tk.stop();$/;"	p	file:	signature:()
stride	softcascade.cpp	/^    const int stride      = opts.stride;$/;"	l
stride	softcascade.hpp	/^	int stride;							\/* [4] spatial stride between detection windows *\/$/;"	m	struct:cascadeParameter	access:public
t	softcascade.hpp	/^                Mat t = testData.col(c);$/;"	l
t_child	softcascade.cpp	/^                    const int *t_child   = child.ptr<int>(t);$/;"	l
t_child	softcascade.cpp	/^        const int *t_child = m_child.ptr<int>(i);$/;"	l
t_child	softcascade.hpp	/^					const int *t_child   = m_child.ptr<int>(c);$/;"	l
t_child	softcascade.hpp	/^					const int *t_child   = m_child.ptr<int>(t);$/;"	l
t_conf	softcascade.cpp	/^        vector<double> t_conf;$/;"	l
t_depth	softcascade.cpp	/^        const int *t_depth = m_depth.ptr<int>(i);$/;"	l
t_fids	softcascade.cpp	/^                    const int *t_fids    = fids.ptr<int>(t);$/;"	l
t_fids	softcascade.hpp	/^					const int *t_fids    = m_fids.ptr<int>(c);$/;"	l
t_fids	softcascade.hpp	/^					const int *t_fids    = m_fids.ptr<int>(t);$/;"	l
t_hs	softcascade.cpp	/^                    const double *t_hs   = hs.ptr<double>(t);$/;"	l
t_hs	softcascade.hpp	/^					const double *t_hs   = m_hs.ptr<double>(c);$/;"	l
t_hs	softcascade.hpp	/^					const double *t_hs   = m_hs.ptr<double>(t);$/;"	l
t_path	main.cpp	/^        bf::path t_path( image_path_vector[c]);$/;"	p	file:	signature:( image_path_vector[c])
t_path	main.cpp	/^        bf::path t_path( image_path_vector[i]);$/;"	p	file:	signature:( image_path_vector[i])
t_tar	softcascade.cpp	/^        vector<Rect> t_tar;$/;"	l
t_thrs	softcascade.cpp	/^                    const double *t_thrs = thrs.ptr<double>(t);$/;"	l
t_thrs	softcascade.hpp	/^					const double *t_thrs = m_thrs.ptr<double>(c);$/;"	l
t_thrs	softcascade.hpp	/^					const double *t_thrs = m_thrs.ptr<double>(t);$/;"	l
t_v	main.cpp	/^		vector<Adaboost> t_v;$/;"	l
target_obj	main.cpp	/^                Mat target_obj = cropImage( im, target_rects[i]);$/;"	l
target_obj	main.cpp	/^                Mat target_obj = cropImage( img, target_rects[i]);$/;"	l
target_rects	main.cpp	/^			vector<Rect> target_rects;$/;"	l
target_rects	main.cpp	/^		vector<Rect> target_rects;$/;"	l
target_rects	main.cpp	/^            fst["boxes"]>>target_rects;$/;"	l
target_rects	main.cpp	/^            vector<Rect> target_rects;$/;"	l
target_rects	main.cpp	/^        fst["boxes"]>>target_rects;$/;"	l
test_img	main.cpp	/^		Mat test_img = imread( image_path_vector[i]);$/;"	l
test_img	main.cpp	/^        Mat test_img = imread( pathname );$/;"	l
test_img	main.cpp	/^        Mat test_img = imread("crop001573.png");$/;"	l
test_neg_all	main.cpp	/^    vector<Mat> test_neg_all;$/;"	l
test_neg_orig	main.cpp	/^    vector<Mat> test_neg_orig;$/;"	l
test_pos_all	main.cpp	/^    vector<Mat> test_pos_all;$/;"	l
test_pos_orig	main.cpp	/^    vector<Mat> test_pos_orig;$/;"	l
testset_neg_path	main.cpp	/^    string testset_neg_path =       "\/home\/yuanyang\/Workspace\/INRIA\/Test\/neg\/";$/;"	l
testset_neg_path	main.cpp	/^    string testset_neg_path = "\/home\/pcipci\/mzx\/ped_detect\/Inria\/Test\/neg\/";$/;"	l
testset_neg_path	main.cpp	/^    string testset_neg_path = "\/media\/yuanyang\/disk1\/libs\/piotr_toolbox\/data\/Inria\/Test\/neg\/";$/;"	l
testset_neg_path	main.cpp	/^    string testset_neg_path = "\/mnt\/disk1\/data\/INRIAPerson\/Test\/neg\/";$/;"	l
testset_pos_gt_path	main.cpp	/^    string testset_pos_gt_path =    "\/home\/yuanyang\/Workspace\/INRIA\/Test\/AnnotTest\/";$/;"	l
testset_pos_gt_path	main.cpp	/^    string testset_pos_gt_path = "\/home\/pcipci\/mzx\/ped_detect\/Inria\/Test\/AnnotTest\/";$/;"	l
testset_pos_gt_path	main.cpp	/^    string testset_pos_gt_path = "\/media\/yuanyang\/disk1\/libs\/piotr_toolbox\/data\/Inria\/Test\/AnnotTest\/";$/;"	l
testset_pos_gt_path	main.cpp	/^    string testset_pos_gt_path = "\/mnt\/disk1\/data\/INRIAPerson\/Test\/AnnotTest\/";$/;"	l
testset_pos_image_path	main.cpp	/^    string testset_pos_image_path = "\/home\/pcipci\/mzx\/ped_detect\/Inria\/Test\/pos\/";$/;"	l
testset_pos_image_path	main.cpp	/^    string testset_pos_image_path = "\/home\/yuanyang\/Workspace\/INRIA\/Test\/pos\/";$/;"	l
testset_pos_image_path	main.cpp	/^    string testset_pos_image_path = "\/media\/yuanyang\/disk1\/libs\/piotr_toolbox\/data\/Inria\/Test\/pos\/";$/;"	l
testset_pos_image_path	main.cpp	/^    string testset_pos_image_path = "\/mnt\/disk1\/data\/INRIAPerson\/Test\/pos\/";$/;"	l
tk	main.cpp	/^    TickMeter tk;$/;"	l
tmp	main.cpp	/^                Mat tmp = pos_train_data.col(c);$/;"	l
tmp	main.cpp	/^            Mat tmp = neg_train_data.col(c);$/;"	l
tmp	main.cpp	/^        Mat tmp = neg_test_data.col(c);$/;"	l
tmp	main.cpp	/^        Mat tmp = pos_test_data.col(c);$/;"	l
tmp	softcascade.hpp	/^            Mat tmp;        \/* copy each vector into it, since opencv matrix is store by rows, *column* is not continuous in memory(except single column) *\/$/;"	l
total_dim	softcascade.cpp	/^    int total_dim = modelHeight\/shrink*modelWidth\/shrink*nchannels;$/;"	l
tree_nodes	softcascade.cpp	/^    int tree_nodes = 0;$/;"	l
tree_par	main.cpp	/^    tree_para tree_par;$/;"	l
union_area	main.cpp	/^	double union_area = r1.width*r1.height + r2.width*r2.height - intersect.width*intersect.height;$/;"	l
v_ab	main.cpp	/^    vector<Adaboost> v_ab;$/;"	l
v_features	softcascade.cpp	/^    vector<Mat> v_features;v_features.resize( number_channels);$/;"	l
visulizeFeature	softcascade.cpp	/^void softcascade::visulizeFeature()$/;"	f	class:softcascade	signature:()
visulizeFeature	softcascade.hpp	/^        void visulizeFeature();$/;"	p	class:softcascade	access:private	signature:()
w_f	main.cpp	/^	int w_f = modelDs.width\/shrink;$/;"	l
w_in_data	main.cpp	/^	int w_in_data = in_data[0].cols;$/;"	l
w_ratio	main.cpp	/^                double w_ratio = modelDsBig_width*1.0\/opts.modelDs.width;$/;"	l
