!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
Apply	softcascade.cpp	/^bool softcascade::Apply( const Mat &input_data,         \/*  in: featuredim x number_of_samples *\/$/;"	f	class:softcascade	signature:( const Mat &input_data, vector<Rect> &results ) const
Apply	softcascade.hpp	/^		bool Apply( const Mat &input_data,		    \/*  in: featuredim x number_of_samples *\/$/;"	p	class:softcascade	access:public	signature:( const Mat &input_data, vector<Rect> &results ) const
Combine	softcascade.cpp	/^bool softcascade::Combine(vector<Adaboost> &ads )$/;"	f	class:softcascade	signature:(vector<Adaboost> &ads )
Combine	softcascade.hpp	/^		bool Combine( vector<Adaboost> &ads );$/;"	p	class:softcascade	access:public	signature:( vector<Adaboost> &ads )
Combine	test.cpp	/^	sc.Combine( abs);$/;"	p	file:	signature:( abs)
Load	softcascade.cpp	/^bool softcascade::Load( string path_to_model )      \/* in : path of the model, shoule be a xml file saved by opencv FileStorage *\/$/;"	f	class:softcascade	signature:( string path_to_model )
Load	softcascade.hpp	/^		bool Load( string path_to_model );		\/* in : path of the model, shoule be a xml file saved by opencv FileStorage *\/$/;"	p	class:softcascade	access:public	signature:( string path_to_model )
Predict	softcascade.hpp	/^		template < typename T> bool Predict(  T *data, double &score) const$/;"	f	class:softcascade	access:public	signature:( T *data, double &score) const
Predict	test.cpp	/^		sc.Predict( pp, h );$/;"	p	file:	signature:( pp, h )
SOFTCASCADE	softcascade.hpp	2;"	d
Save	softcascade.cpp	/^bool softcascade::Save( string path_to_model )      \/*  in: where to save the model, models is saved by opencv FileStorage *\/$/;"	f	class:softcascade	signature:( string path_to_model )
Save	softcascade.hpp	/^		bool Save( string path_to_model );		\/*  in: where to save the model, models is saved by opencv FileStorage *\/$/;"	p	class:softcascade	access:public	signature:( string path_to_model )
_apply	softcascade.cpp	/^template <typename T> void _apply( const T *input_data,                 \/* in : (nchannels*nheight)x(nwidth) channels feature, already been scaled with shrink*\/$/;"	f	signature:( const T *input_data, const int &in_width, const int &in_height, const int &nchannels, const Mat &fids, const Mat &child, const Mat &thrs, const Mat &hs, const cascadeParameter &opts, const int &tree_depth, vector<Rect> &results, vector<double> &confidence )
ab1	test.cpp	/^	Adaboost ab1,ab2,ab3;$/;"	l
ab2	test.cpp	/^	Adaboost ab1,ab2,ab3;$/;"	l
ab3	test.cpp	/^	Adaboost ab1,ab2,ab3;$/;"	l
abs	test.cpp	/^	vector<Adaboost> abs;$/;"	l
at	softcascade.cpp	/^            m_nodes.at<int>(counter,0) = nodes_info.at<int>(i,0);$/;"	p	file:	signature:(counter,0)
basename	main.cpp	/^            string basename = bf::basename( s );$/;"	l
bts	softcascade.cpp	/^        const vector<binaryTree> bts = ads[c].getTrees();$/;"	l
c_path	main.cpp	/^    bf::path c_path(in_path);   $/;"	p	file:	signature:(in_path)
cas_para	main.cpp	/^	cascadeParameter cas_para;$/;"	l
cascCal	softcascade.cpp	/^    const double cascCal  = opts.cascCal;$/;"	l
cascCal	softcascade.hpp	/^	double cascCal;						\/* [.005] cascade calibration (affects speed\/accuracy) *\/$/;"	m	struct:cascadeParameter	access:public
cascThr	softcascade.cpp	/^    const double cascThr  = opts.cascThr;$/;"	l
cascThr	softcascade.hpp	/^	double cascThr;						\/* [-1] constant cascade threshold (affects speed\/accuracy)*\/$/;"	m	struct:cascadeParameter	access:public
cascadeParameter	softcascade.hpp	/^	cascadeParameter()$/;"	f	struct:cascadeParameter	access:public	signature:()
cascadeParameter	softcascade.hpp	/^struct cascadeParameter$/;"	s
cascadeParameter::cascCal	softcascade.hpp	/^	double cascCal;						\/* [.005] cascade calibration (affects speed\/accuracy) *\/$/;"	m	struct:cascadeParameter	access:public
cascadeParameter::cascThr	softcascade.hpp	/^	double cascThr;						\/* [-1] constant cascade threshold (affects speed\/accuracy)*\/$/;"	m	struct:cascadeParameter	access:public
cascadeParameter::cascadeParameter	softcascade.hpp	/^	cascadeParameter()$/;"	f	struct:cascadeParameter	access:public	signature:()
cascadeParameter::filter	softcascade.hpp	/^	vector<int> filter;					\/* de-correlation filter parameters, eg [5 5]  *\/$/;"	m	struct:cascadeParameter	access:public
cascadeParameter::infos	softcascade.hpp	/^	string infos;						\/* other informations~~ *\/$/;"	m	struct:cascadeParameter	access:public
cascadeParameter::modelDs	softcascade.hpp	/^	Size modelDs;						\/* model height+width without padding (eg [100 41]) *\/$/;"	m	struct:cascadeParameter	access:public
cascadeParameter::modelDsPad	softcascade.hpp	/^	Size modelDsPad;					\/* model height+width with padding (eg [128 64])*\/$/;"	m	struct:cascadeParameter	access:public
cascadeParameter::nAccNeg	softcascade.hpp	/^	int nAccNeg;						\/* [10000] max number of neg windows to accumulate*\/$/;"	m	struct:cascadeParameter	access:public
cascadeParameter::nNeg	softcascade.hpp	/^	int nNeg;							\/* [5000] max number of neg windows to sample*\/$/;"	m	struct:cascadeParameter	access:public
cascadeParameter::nPerNeg	softcascade.hpp	/^	int nPerNeg;						\/* [25]  max number of neg windows to sample per image*\/$/;"	m	struct:cascadeParameter	access:public
cascadeParameter::nPos	softcascade.hpp	/^	int nPos;							\/* [-1 -> inf] max number of pos windows to sample *\/						$/;"	m	struct:cascadeParameter	access:public
cascadeParameter::nWeaks	softcascade.hpp	/^	vector<int> nWeaks;					\/* [128] vector defining number weak clfs per stagemodel eg[64 128 256 1024]*\/$/;"	m	struct:cascadeParameter	access:public
cascadeParameter::negImgDir	softcascade.hpp	/^    string negImgDir;                   \/* negative image directory *\/$/;"	m	struct:cascadeParameter	access:public
cascadeParameter::pBoost_nweaks	softcascade.hpp	/^	int pBoost_nweaks;					\/* parameters for boosting *\/$/;"	m	struct:cascadeParameter	access:public
cascadeParameter::pBoost_pTree	softcascade.hpp	/^	tree_para pBoost_pTree;				\/* parameters for boosting *\/$/;"	m	struct:cascadeParameter	access:public
cascadeParameter::posGtDir	softcascade.hpp	/^    string posGtDir;                    \/* positive groundtruth directory *\/$/;"	m	struct:cascadeParameter	access:public
cascadeParameter::posImgDir	softcascade.hpp	/^    string posImgDir;                   \/* positive image directory *\/$/;"	m	struct:cascadeParameter	access:public
cascadeParameter::shrink	softcascade.hpp	/^	int shrink;							\/* ----------> should be provided by the chnPyramid *\/$/;"	m	struct:cascadeParameter	access:public
cascadeParameter::stride	softcascade.hpp	/^	int stride;							\/* [4] spatial stride between detection windows *\/$/;"	m	struct:cascadeParameter	access:public
checkModel	softcascade.cpp	/^bool softcascade::checkModel() const$/;"	f	class:softcascade	signature:() const
checkModel	softcascade.hpp	/^		bool checkModel() const;$/;"	p	class:softcascade	access:public	signature:() const
cids	softcascade.cpp	/^    unsigned int *cids = new unsigned int[total_dim];$/;"	l
clear	main.cpp	/^    origsamples.clear();$/;"	p	file:	signature:()
clear	main.cpp	/^    samples.clear();$/;"	p	file:	signature:()
cnt	main.cpp	/^    int cnt = std::count_if($/;"	l
copyTo	softcascade.cpp	/^            (*ptr).child.copyTo( m_child.row(counter).colRange(0,nodes_info.at<int>(i,0)) );$/;"	p	file:	signature:( m_child.row(counter).colRange(0,nodes_info.at<int>(i,0)) )
copyTo	softcascade.cpp	/^            (*ptr).depth.copyTo( m_depth.row(counter).colRange(0,nodes_info.at<int>(i,0)) );$/;"	p	file:	signature:( m_depth.row(counter).colRange(0,nodes_info.at<int>(i,0)) )
copyTo	softcascade.cpp	/^            (*ptr).fids.copyTo( m_fids.row(counter).colRange(0,nodes_info.at<int>(i,0)) );$/;"	p	file:	signature:( m_fids.row(counter).colRange(0,nodes_info.at<int>(i,0)) )
copyTo	softcascade.cpp	/^            (*ptr).hs.copyTo( m_hs.row(counter).colRange(0,nodes_info.at<int>(i,0)) );$/;"	p	file:	signature:( m_hs.row(counter).colRange(0,nodes_info.at<int>(i,0)) )
copyTo	softcascade.cpp	/^            (*ptr).thrs.copyTo( m_thrs.row(counter).colRange(0,nodes_info.at<int>(i,0)) );$/;"	p	file:	signature:( m_thrs.row(counter).colRange(0,nodes_info.at<int>(i,0)) )
copyTo	softcascade.cpp	/^            (*ptr).weights.copyTo( m_weights.row(counter).colRange(0,nodes_info.at<int>(i,0)) );$/;"	p	file:	signature:( m_weights.row(counter).colRange(0,nodes_info.at<int>(i,0)) )
counter	softcascade.cpp	/^    int counter = 0;$/;"	l
counter	softcascade.cpp	/^    int counter=0;$/;"	l
depppth	softcascade.cpp	/^    int depppth = m_depth.at<int>(0,m_tree_nodes-1);$/;"	l
end_it	main.cpp	/^        bf::directory_iterator end_it; int file_counter = 0;int number_target = 0;$/;"	l
endl	main.cpp	/^		cout<<"Training Stage No "<<stage<<endl;$/;"	l
endl	main.cpp	/^                cout<<"can not read gt file "<<gt_file_path<<endl;$/;"	l
endl	main.cpp	/^                cout<<"can not read image file "<<pathname<<endl;$/;"	l
endl	main.cpp	/^            cout<<"check "<<pos_img_path<<"  and "<<pos_gt_path<<endl;$/;"	l
endl	main.cpp	/^            cout<<"pos img or gt path does not exist!"<<endl;$/;"	l
endl	softcascade.cpp	/^            cout<<"<softcascade::Combine><error> Adaboost struct is empty .. "<<endl;$/;"	l
endl	softcascade.cpp	/^        cout<<"<softcascade::Apply><error> input_data shoule be continuous ~"<<endl;$/;"	l
endl	softcascade.cpp	/^        cout<<"<softcascade::Load><error> Can not load model file "<<path_to_model<<endl;$/;"	l
endl	softcascade.cpp	/^        cout<<"<softcascade::Save><error> can not open file "<<path_to_model<<" for writing ."<<endl;$/;"	l
endl	softcascade.cpp	/^        cout<<"<softcascade::checkModel><error> Model is empty "<<endl;$/;"	l
endl	softcascade.cpp	/^        cout<<"<softcascade::checkModel><error> Model is not continuous "<<endl;$/;"	l
endl	softcascade.cpp	/^        cout<<"Making model from adaboost structure ..."<<endl;$/;"	l
endl	softcascade.cpp	/^        cout<<"max_number_of_nodes is \\n"<<max_number_of_nodes<<endl;$/;"	l
endl	softcascade.cpp	/^        cout<<"number_of_trees is \\n"<<number_of_trees<<endl;$/;"	l
endl	softcascade.cpp	/^        cout<<"the depth of the trees is "<<m_tree_depth<<endl;$/;"	l
endl	softcascade.cpp	/^        cout<<"tree_nodes is \\n"<<tree_nodes<<endl;$/;"	l
endl	softcascade.cpp	/^    cout<<"Loading Model Done "<<endl;$/;"	l
endl	softcascade.cpp	/^    cout<<"Saving Model Done "<<endl;$/;"	l
extname	main.cpp	/^            string extname  = bf::extension( s );$/;"	l
file_counter	main.cpp	/^        bf::directory_iterator end_it; int file_counter = 0;int number_target = 0;$/;"	l
filter	softcascade.hpp	/^	vector<int> filter;					\/* de-correlation filter parameters, eg [5 5]  *\/$/;"	m	struct:cascadeParameter	access:public
fn	test.cpp	/^	int fn = 0;$/;"	l
fp	test.cpp	/^	int fp = 0;$/;"	l
fs	softcascade.cpp	/^    FileStorage fs( path_to_model, FileStorage::WRITE);$/;"	p	file:	signature:( path_to_model, FileStorage::WRITE)
fs	softcascade.cpp	/^    FileStorage fs(path_to_model, FileStorage::READ );$/;"	p	file:	signature:(path_to_model, FileStorage::READ )
fs	test.cpp	/^	FileStorage fs;$/;"	l
fst	main.cpp	/^            FileStorage fst( gt_file_path, FileStorage::READ | FileStorage::FORMAT_XML);$/;"	p	file:	signature:( gt_file_path, FileStorage::READ | FileStorage::FORMAT_XML)
getNumberOfFilesInDir	main.cpp	/^size_t getNumberOfFilesInDir( string in_path )$/;"	f	signature:( string in_path )
getParas	softcascade.cpp	/^const cascadeParameter& softcascade::getParas() const$/;"	f	class:softcascade	signature:() const
getParas	softcascade.hpp	/^		const cascadeParameter& getParas() const;$/;"	p	class:softcascade	access:public	signature:() const
gt_file_path	main.cpp	/^            string gt_file_path = opts.posImgDir + basename + ".txt";$/;"	l
h	softcascade.cpp	/^            double h=0;$/;"	l
h	softcascade.hpp	/^			double h = 0;$/;"	l
h	test.cpp	/^		double h = 0;$/;"	l
h_ratio	main.cpp	/^                double h_ratio = modelDsBig_height*1.0\/opts.modelDs.height;$/;"	l
im	main.cpp	/^            Mat im = imread(pathname);$/;"	l
infos	softcascade.hpp	/^	string infos;						\/* other informations~~ *\/$/;"	m	struct:cascadeParameter	access:public
m_child	softcascade.cpp	/^    fs<<"m_child"<<m_child;$/;"	l
m_child	softcascade.cpp	/^    fs["m_child"]>>m_child;$/;"	l
m_child	softcascade.hpp	/^		Mat m_child;						\/* nxK 32S child index for each node *\/$/;"	m	class:softcascade	access:private
m_debug	softcascade.hpp	/^		bool m_debug;						\/* wanna output? *\/$/;"	m	class:softcascade	access:private
m_depth	softcascade.cpp	/^    fs<<"m_depth"<<m_depth;$/;"	l
m_depth	softcascade.cpp	/^    fs["m_depth"] >> m_depth;$/;"	l
m_depth	softcascade.hpp	/^		Mat m_depth;						\/* nxK 32S depth of node*\/$/;"	m	class:softcascade	access:private
m_fids	softcascade.cpp	/^    fs<<"m_fids"<<m_fids;$/;"	l
m_fids	softcascade.cpp	/^    fs["m_fids"]>>m_fids;$/;"	l
m_fids	softcascade.hpp	/^		Mat m_fids;							\/* nxK 32S feature index for each node , n -> number of trees, K -> number of nodes*\/$/;"	m	class:softcascade	access:private
m_hs	softcascade.cpp	/^    fs<<"m_hs"<<m_hs;$/;"	l
m_hs	softcascade.cpp	/^    fs["m_hs"]>>m_hs;$/;"	l
m_hs	softcascade.hpp	/^		Mat m_hs;							\/* nxK 64F log ratio (.5*log(p\/(1-p)) at each node  *\/$/;"	m	class:softcascade	access:private
m_nodes	softcascade.cpp	/^    fs<<"m_nodes"<<m_nodes;$/;"	l
m_nodes	softcascade.cpp	/^    fs["m_nodes"]>>m_nodes;$/;"	l
m_nodes	softcascade.hpp	/^		Mat m_nodes;						\/* nx1 32S number of nodes of each tree *\/$/;"	m	class:softcascade	access:private
m_number_of_trees	softcascade.cpp	/^    fs<<"m_number_of_trees"<<m_number_of_trees;$/;"	l
m_number_of_trees	softcascade.cpp	/^    fs["m_number_of_trees"]>>m_number_of_trees;$/;"	l
m_number_of_trees	softcascade.hpp	/^		int m_number_of_trees;				\/* . *\/$/;"	m	class:softcascade	access:private
m_opts	softcascade.hpp	/^		cascadeParameter m_opts;            \/* detectot options  *\/$/;"	m	class:softcascade	access:private
m_thrs	softcascade.cpp	/^    fs<<"m_thrs"<<m_thrs;$/;"	l
m_thrs	softcascade.cpp	/^    fs["m_thrs"]>>m_thrs;$/;"	l
m_thrs	softcascade.hpp	/^		Mat m_thrs;							\/* nxK 64F thresholds for each node *\/$/;"	m	class:softcascade	access:private
m_tree_depth	softcascade.hpp	/^		int m_tree_depth;					\/* depth of all leaf nodes (or 0 if leaf depth varies) *\/$/;"	m	class:softcascade	access:private
m_tree_nodes	softcascade.cpp	/^    fs<<"m_tree_nodes"<<m_tree_nodes;$/;"	l
m_tree_nodes	softcascade.cpp	/^    fs["m_tree_nodes"]>>m_tree_nodes;$/;"	l
m_tree_nodes	softcascade.hpp	/^		int m_tree_nodes;					\/* if all the tree have the same structure, this will be the number of the nodes of each tree, otherwise -1*\/$/;"	m	class:softcascade	access:private
m_weights	softcascade.cpp	/^    fs<<"m_weights"<<m_weights;$/;"	l
m_weights	softcascade.cpp	/^    fs["m_weights"]>>m_weights;$/;"	l
m_weights	softcascade.hpp	/^		Mat m_weights;						\/* nxK 64F total sample weight at each node *\/$/;"	m	class:softcascade	access:private
main	main.cpp	/^int main( int argc, char** argv)$/;"	f	signature:( int argc, char** argv)
main	test.cpp	/^int main( int argc, char** argv)$/;"	f	signature:( int argc, char** argv)
max_number_of_nodes	softcascade.cpp	/^    int max_number_of_nodes = 0;$/;"	l
modelDs	softcascade.hpp	/^	Size modelDs;						\/* model height+width without padding (eg [100 41]) *\/$/;"	m	struct:cascadeParameter	access:public
modelDsBig_height	main.cpp	/^                int modelDsBig_height = std::max( 8*opts.shrink,opts.modelDsPad.height)+std::max(2,64\/opts.shrink)*opts.shrink;$/;"	l
modelDsBig_width	main.cpp	/^                int modelDsBig_width = std::max( 8*opts.shrink, opts.modelDsPad.width)+std::max(2, 64\/opts.shrink)*opts.shrink;$/;"	l
modelDsPad	softcascade.hpp	/^	Size modelDsPad;					\/* model height+width with padding (eg [128 64])*\/$/;"	m	struct:cascadeParameter	access:public
modelHeight	softcascade.cpp	/^    const int modelHeight = opts.modelDsPad.height;$/;"	l
modelWidth	softcascade.cpp	/^    const int modelWidth  = opts.modelDsPad.width;$/;"	l
nAccNeg	softcascade.hpp	/^	int nAccNeg;						\/* [10000] max number of neg windows to accumulate*\/$/;"	m	struct:cascadeParameter	access:public
nNeg	softcascade.hpp	/^	int nNeg;							\/* [5000] max number of neg windows to sample*\/$/;"	m	struct:cascadeParameter	access:public
nPerNeg	softcascade.hpp	/^	int nPerNeg;						\/* [25]  max number of neg windows to sample per image*\/$/;"	m	struct:cascadeParameter	access:public
nPos	softcascade.hpp	/^	int nPos;							\/* [-1 -> inf] max number of pos windows to sample *\/						$/;"	m	struct:cascadeParameter	access:public
nWeaks	softcascade.hpp	/^	vector<int> nWeaks;					\/* [128] vector defining number weak clfs per stagemodel eg[64 128 256 1024]*\/$/;"	m	struct:cascadeParameter	access:public
n_height	softcascade.cpp	/^    int n_height = (int) ceil((in_height*shrink-modelHeight+1)\/stride);$/;"	l
n_width	softcascade.cpp	/^    int n_width  = (int) ceil((in_width*shrink-modelWidth+1)\/stride);$/;"	l
negImgDir	softcascade.hpp	/^    string negImgDir;                   \/* negative image directory *\/$/;"	m	struct:cascadeParameter	access:public
nodes_info	softcascade.cpp	/^        Mat nodes_info = ads[c].getNodes();$/;"	l
number_of_nodes	softcascade.cpp	/^    const int number_of_nodes = fids.cols;$/;"	l
number_of_trees	softcascade.cpp	/^    const int number_of_trees = fids.rows;$/;"	l
number_of_trees	softcascade.cpp	/^    int number_of_trees = 0;$/;"	l
number_pos_img	main.cpp	/^        int number_pos_img = getNumberOfFilesInDir( opts.posGtDir );$/;"	l
number_target	main.cpp	/^        bf::directory_iterator end_it; int file_counter = 0;int number_target = 0;$/;"	l
number_to_sample	main.cpp	/^    int number_to_sample = 0;$/;"	l
opts	main.cpp	/^    cascadeParameter opts = sc.getParas();$/;"	l
pBoost_nweaks	softcascade.hpp	/^	int pBoost_nweaks;					\/* parameters for boosting *\/$/;"	m	struct:cascadeParameter	access:public
pBoost_pTree	softcascade.hpp	/^	tree_para pBoost_pTree;				\/* parameters for boosting *\/$/;"	m	struct:cascadeParameter	access:public
pathname	main.cpp	/^            string pathname = file_iter->path().string();$/;"	l
posGtDir	softcascade.hpp	/^    string posGtDir;                    \/* positive groundtruth directory *\/$/;"	m	struct:cascadeParameter	access:public
posImgDir	softcascade.hpp	/^    string posImgDir;                   \/* positive image directory *\/$/;"	m	struct:cascadeParameter	access:public
pos_gt_path	main.cpp	/^        bf::path pos_gt_path( opts.posGtDir );$/;"	p	file:	signature:( opts.posGtDir )
pos_img_path	main.cpp	/^        bf::path pos_img_path( opts.posImgDir );$/;"	p	file:	signature:( opts.posImgDir )
position	softcascade.cpp	/^                    int position = 0;$/;"	l
position	softcascade.hpp	/^					int position   = 0;$/;"	l
position	softcascade.hpp	/^					int position = 0;$/;"	l
pp	test.cpp	/^		double* pp = test_neg.ptr<double>(c);$/;"	l
pp	test.cpp	/^		double* pp = test_pos.ptr<double>(c);$/;"	l
probe_feature_starter	softcascade.cpp	/^            T *probe_feature_starter = input_data + (h*stride\/shrink)*in_width + (w*stride\/shrink);$/;"	l
ptr	softcascade.cpp	/^            const biTree *ptr = bts[i].getTree();       $/;"	l
push_back	main.cpp	/^                origsamples.push_back( target_obj );$/;"	p	file:	signature:( target_obj )
push_back	softcascade.cpp	/^                confidence.push_back( h );$/;"	p	file:	signature:( h )
push_back	softcascade.cpp	/^                results.push_back( tmp );$/;"	p	file:	signature:( tmp )
push_back	test.cpp	/^	abs.push_back( ab1 );$/;"	p	file:	signature:( ab1 )
release	main.cpp	/^            fst.release();$/;"	p	file:	signature:()
release	softcascade.cpp	/^    fs.release();$/;"	p	file:	signature:()
release	test.cpp	/^	fs.release();$/;"	p	file:	signature:()
s	main.cpp	/^            bf::path s = *(file_iter);$/;"	l
sampleWins	main.cpp	/^bool sampleWins(    const softcascade &sc, 	    \/*  in: detector *\/$/;"	f	signature:( const softcascade &sc, int stage, bool isPositive, vector<Mat> &samples, vector<Mat> &origsamples)
sc	main.cpp	/^    softcascade sc;$/;"	l
sc	test.cpp	/^	softcascade sc;$/;"	l
setParas	softcascade.cpp	/^void softcascade::setParas( const cascadeParameter &in_par )$/;"	f	class:softcascade	signature:( const cascadeParameter &in_par )
setParas	softcascade.hpp	/^        void setParas( const cascadeParameter &in_par );$/;"	p	class:softcascade	access:public	signature:( const cascadeParameter &in_par )
setTreeDepth	softcascade.cpp	/^bool softcascade::setTreeDepth()$/;"	f	class:softcascade	signature:()
setTreeDepth	softcascade.hpp	/^		bool setTreeDepth();$/;"	p	class:softcascade	access:private	signature:()
shrink	softcascade.cpp	/^    const int shrink = opts.shrink;$/;"	l
shrink	softcascade.hpp	/^	int shrink;							\/* ----------> should be provided by the chnPyramid *\/$/;"	m	struct:cascadeParameter	access:public
softcascade	softcascade.hpp	/^class softcascade$/;"	c
softcascade::Apply	softcascade.cpp	/^bool softcascade::Apply( const Mat &input_data,         \/*  in: featuredim x number_of_samples *\/$/;"	f	class:softcascade	signature:( const Mat &input_data, vector<Rect> &results ) const
softcascade::Apply	softcascade.hpp	/^		bool Apply( const Mat &input_data,		    \/*  in: featuredim x number_of_samples *\/$/;"	p	class:softcascade	access:public	signature:( const Mat &input_data, vector<Rect> &results ) const
softcascade::Combine	softcascade.cpp	/^bool softcascade::Combine(vector<Adaboost> &ads )$/;"	f	class:softcascade	signature:(vector<Adaboost> &ads )
softcascade::Combine	softcascade.hpp	/^		bool Combine( vector<Adaboost> &ads );$/;"	p	class:softcascade	access:public	signature:( vector<Adaboost> &ads )
softcascade::Load	softcascade.cpp	/^bool softcascade::Load( string path_to_model )      \/* in : path of the model, shoule be a xml file saved by opencv FileStorage *\/$/;"	f	class:softcascade	signature:( string path_to_model )
softcascade::Load	softcascade.hpp	/^		bool Load( string path_to_model );		\/* in : path of the model, shoule be a xml file saved by opencv FileStorage *\/$/;"	p	class:softcascade	access:public	signature:( string path_to_model )
softcascade::Predict	softcascade.hpp	/^		template < typename T> bool Predict(  T *data, double &score) const$/;"	f	class:softcascade	access:public	signature:( T *data, double &score) const
softcascade::Save	softcascade.cpp	/^bool softcascade::Save( string path_to_model )      \/*  in: where to save the model, models is saved by opencv FileStorage *\/$/;"	f	class:softcascade	signature:( string path_to_model )
softcascade::Save	softcascade.hpp	/^		bool Save( string path_to_model );		\/*  in: where to save the model, models is saved by opencv FileStorage *\/$/;"	p	class:softcascade	access:public	signature:( string path_to_model )
softcascade::checkModel	softcascade.cpp	/^bool softcascade::checkModel() const$/;"	f	class:softcascade	signature:() const
softcascade::checkModel	softcascade.hpp	/^		bool checkModel() const;$/;"	p	class:softcascade	access:public	signature:() const
softcascade::getParas	softcascade.cpp	/^const cascadeParameter& softcascade::getParas() const$/;"	f	class:softcascade	signature:() const
softcascade::getParas	softcascade.hpp	/^		const cascadeParameter& getParas() const;$/;"	p	class:softcascade	access:public	signature:() const
softcascade::h	softcascade.hpp	/^			double h = 0;$/;"	l
softcascade::m_child	softcascade.hpp	/^		Mat m_child;						\/* nxK 32S child index for each node *\/$/;"	m	class:softcascade	access:private
softcascade::m_debug	softcascade.hpp	/^		bool m_debug;						\/* wanna output? *\/$/;"	m	class:softcascade	access:private
softcascade::m_depth	softcascade.hpp	/^		Mat m_depth;						\/* nxK 32S depth of node*\/$/;"	m	class:softcascade	access:private
softcascade::m_fids	softcascade.hpp	/^		Mat m_fids;							\/* nxK 32S feature index for each node , n -> number of trees, K -> number of nodes*\/$/;"	m	class:softcascade	access:private
softcascade::m_hs	softcascade.hpp	/^		Mat m_hs;							\/* nxK 64F log ratio (.5*log(p\/(1-p)) at each node  *\/$/;"	m	class:softcascade	access:private
softcascade::m_nodes	softcascade.hpp	/^		Mat m_nodes;						\/* nx1 32S number of nodes of each tree *\/$/;"	m	class:softcascade	access:private
softcascade::m_number_of_trees	softcascade.hpp	/^		int m_number_of_trees;				\/* . *\/$/;"	m	class:softcascade	access:private
softcascade::m_opts	softcascade.hpp	/^		cascadeParameter m_opts;            \/* detectot options  *\/$/;"	m	class:softcascade	access:private
softcascade::m_thrs	softcascade.hpp	/^		Mat m_thrs;							\/* nxK 64F thresholds for each node *\/$/;"	m	class:softcascade	access:private
softcascade::m_tree_depth	softcascade.hpp	/^		int m_tree_depth;					\/* depth of all leaf nodes (or 0 if leaf depth varies) *\/$/;"	m	class:softcascade	access:private
softcascade::m_tree_nodes	softcascade.hpp	/^		int m_tree_nodes;					\/* if all the tree have the same structure, this will be the number of the nodes of each tree, otherwise -1*\/$/;"	m	class:softcascade	access:private
softcascade::m_weights	softcascade.hpp	/^		Mat m_weights;						\/* nxK 64F total sample weight at each node *\/$/;"	m	class:softcascade	access:private
softcascade::position	softcascade.hpp	/^					int position   = 0;$/;"	l
softcascade::position	softcascade.hpp	/^					int position = 0;$/;"	l
softcascade::setParas	softcascade.cpp	/^void softcascade::setParas( const cascadeParameter &in_par )$/;"	f	class:softcascade	signature:( const cascadeParameter &in_par )
softcascade::setParas	softcascade.hpp	/^        void setParas( const cascadeParameter &in_par );$/;"	p	class:softcascade	access:public	signature:( const cascadeParameter &in_par )
softcascade::setTreeDepth	softcascade.cpp	/^bool softcascade::setTreeDepth()$/;"	f	class:softcascade	signature:()
softcascade::setTreeDepth	softcascade.hpp	/^		bool setTreeDepth();$/;"	p	class:softcascade	access:private	signature:()
softcascade::t_child	softcascade.hpp	/^					const int *t_child   = m_child.ptr<int>(c);$/;"	l
softcascade::t_child	softcascade.hpp	/^					const int *t_child   = m_child.ptr<int>(t);$/;"	l
softcascade::t_fids	softcascade.hpp	/^					const int *t_fids    = m_fids.ptr<int>(c);$/;"	l
softcascade::t_fids	softcascade.hpp	/^					const int *t_fids    = m_fids.ptr<int>(t);$/;"	l
softcascade::t_hs	softcascade.hpp	/^					const double *t_hs   = m_hs.ptr<double>(c);$/;"	l
softcascade::t_hs	softcascade.hpp	/^					const double *t_hs   = m_hs.ptr<double>(t);$/;"	l
softcascade::t_thrs	softcascade.hpp	/^					const double *t_thrs = m_thrs.ptr<double>(c);$/;"	l
softcascade::t_thrs	softcascade.hpp	/^					const double *t_thrs = m_thrs.ptr<double>(t);$/;"	l
start	main.cpp	/^		tk.start();$/;"	p	file:	signature:()
start	test.cpp	/^	tk.start();$/;"	p	file:	signature:()
stop	main.cpp	/^		tk.stop();$/;"	p	file:	signature:()
stop	test.cpp	/^	tk.stop();$/;"	p	file:	signature:()
stride	softcascade.cpp	/^    const int stride      = opts.stride;$/;"	l
stride	softcascade.hpp	/^	int stride;							\/* [4] spatial stride between detection windows *\/$/;"	m	struct:cascadeParameter	access:public
t_child	softcascade.cpp	/^                    const int *t_child   = child.ptr<int>(t);$/;"	l
t_child	softcascade.cpp	/^        const int *t_child = m_child.ptr<int>(i);$/;"	l
t_child	softcascade.hpp	/^					const int *t_child   = m_child.ptr<int>(c);$/;"	l
t_child	softcascade.hpp	/^					const int *t_child   = m_child.ptr<int>(t);$/;"	l
t_depth	softcascade.cpp	/^        const int *t_depth = m_depth.ptr<int>(i);$/;"	l
t_fids	softcascade.cpp	/^                    const int *t_fids    = fids.ptr<int>(t);$/;"	l
t_fids	softcascade.hpp	/^					const int *t_fids    = m_fids.ptr<int>(c);$/;"	l
t_fids	softcascade.hpp	/^					const int *t_fids    = m_fids.ptr<int>(t);$/;"	l
t_hs	softcascade.cpp	/^                    const double *t_hs   = hs.ptr<double>(t);$/;"	l
t_hs	softcascade.hpp	/^					const double *t_hs   = m_hs.ptr<double>(c);$/;"	l
t_hs	softcascade.hpp	/^					const double *t_hs   = m_hs.ptr<double>(t);$/;"	l
t_thrs	softcascade.cpp	/^                    const double *t_thrs = thrs.ptr<double>(t);$/;"	l
t_thrs	softcascade.hpp	/^					const double *t_thrs = m_thrs.ptr<double>(c);$/;"	l
t_thrs	softcascade.hpp	/^					const double *t_thrs = m_thrs.ptr<double>(t);$/;"	l
target_obj	main.cpp	/^                Mat target_obj = cropImage( im, target_rects[i]);$/;"	l
target_rects	main.cpp	/^            fst["boxed"]>>target_rects;$/;"	l
target_rects	main.cpp	/^            vector<Rect> target_rects;$/;"	l
test_neg	test.cpp	/^	Mat test_pos,test_neg;$/;"	l
test_neg	test.cpp	/^	fs["matrix"] >>test_neg;$/;"	l
test_pos	test.cpp	/^	Mat test_pos,test_neg;$/;"	l
test_pos	test.cpp	/^	fs["matrix"] >>test_pos;$/;"	l
tk	main.cpp	/^		TickMeter tk;$/;"	l
tk	test.cpp	/^	cv::TickMeter tk;$/;"	l
tmp	softcascade.cpp	/^                Rect tmp( w*stride, h*stride, modelWidth, modelHeight );$/;"	p	file:	signature:( w*stride, h*stride, modelWidth, modelHeight )
total_dim	softcascade.cpp	/^    int total_dim = modelHeight\/shrink*modelWidth\/shrink*nchannels;$/;"	l
tree_nodes	softcascade.cpp	/^    int tree_nodes = 0;$/;"	l
w_ratio	main.cpp	/^                double w_ratio = modelDsBig_width*1.0\/opts.modelDs.width;$/;"	l
